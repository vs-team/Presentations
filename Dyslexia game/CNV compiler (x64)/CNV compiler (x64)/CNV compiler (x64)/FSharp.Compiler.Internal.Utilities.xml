<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Compiler.Internal.Utilities</name></assembly>
<members>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.TryPeekKeyValue(`0)">
<summary>
 Lookup the value without making it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.TryGetKeyValue(`0)">
<summary>
 Lookup a value and make it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.TryGet(`0)">
<summary>
 Lookup a value and make it the most recent. Return None if it wasn&apos;t there.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.Remove(`0)">
<summary>
 Remove the given value from the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.Put(`0,`1)">
<summary>
 Add an element to the collection. Make it the most recent.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.Clear">
<summary>
 Remove all elements.
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Collections.AgedLookup`2">
<summary>
 Simple aging lookup table. When a member is accessed it&apos;s
 moved to the top of the list and when there are too many elements
 the least-recently-accessed element falls of the end.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0,`1)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Count">
<summary>
 The total number of keys in the hash table
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.TryFind(`0)">
<summary>
 Lookup the given element in the table, returning the result as an Option
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Replace(`0,`1)">
<summary>
 Replace the latest binding (if any) for the given element.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Remove(`0)">
<summary>
 Remove the latest binding (if any) for the given element from the table
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Apply the given function to each element in the collection threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.FindAll(`0)">
<summary>
 Find all bindings for the given element in the table, if any
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Copy">
<summary>
 Make a shallow copy of the collection
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.ContainsKey(`0)">
<summary>
 Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Clear">
<summary>
 Clear all elements from the collection
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Add(`0,`1)">
<summary>
 Add a binding for the element to the table
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable HashMultiMap with an (*internal*) bucket array of the given approximate size
 and with the given key hash/equality functions
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable HashMultiMap with the given key hash/equality functions
</summary>
</member>
<member name="T:Internal.Utilities.Collections.HashMultiMap`2">
<summary>
 Hash tables, by default based on F# structural &quot;hash&quot; and (=) functions. 
 The table may map a single key to multiple bindings.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.List.referenceDistinct``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return each distinct item in the list using reference equality.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.List.groupByFirst``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Return a new list with one element for each unique &apos;TKey. Multiple &apos;TValues are flattened. The original order of the first instance of &apos;TKey is preserved.
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Collections.MruCache`2.MostRecent">
<summary>
 Get the most recent item if there is one.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.SetAlternate(`0,`1)">
<summary>
 Set the value for the given key. This value does not have to agree with computed value.           
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.Remove(`0)">
<summary>
 Remove the given value from the mru cache.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.GetAvailable(`0)">
<summary>
 Get the value for the given key or None if not already available
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.Get(`0)">
<summary>
 Get the value for the given key. Compute if necessary.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.Clear">
<summary>
 Clear out the cache.
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Collections.MruCache`2">
<summary>
 Simple priority caching for a small number of key\value associations.
 This cache may age-out results that have been Set by the caller.
 Because of this, the caller must be able to tolerate values 
 that aren&apos;t what was originally passed to the Set function.         
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Item(`0)">
<summary>
 Lookup an element in the map. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.TryFind(`0)">
<summary>
 Lookup an element in the map, returning a &lt;c&gt;Some&lt;/c&gt; value if the element is in the domain 
 of the map and &lt;c&gt;None&lt;/c&gt; if not.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToArray">
<summary>
 The elements of the set as an array
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Remove(`0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns &apos;true&apos;,
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.MapRange``1(Microsoft.FSharp.Core.FSharpFunc{`1,``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldSection``1(`0,`0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldAndMap``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``0}}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.First``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 Search the map looking for the first element where the given function returns a &lt;c&gt;Some&lt;/c&gt; value
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build a new map containing the bindings for which the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Empty(`2)">
<summary>
 The empty map, and use the given comparer comparison function for all operations associated
 with any maps built from this map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Create(`2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
 and where comparison of elements is based on the given comparison function
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ContainsKey(`0)">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Add(`0,`1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Map`3">
<summary>
 Immutable maps.  Keys are ordered by construction function specified
 when creating empty maps or by F# structural comparison if no
 construction function is specified.

 &lt;performance&gt; 
   Maps based on structural comparison are  
   efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or require non-structural comparison semantics.
 &lt;/performance&gt;
 Immutable maps.  A constraint tag carries information about the class of key-comparers being used.  
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Subtraction(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Addition(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.IsEmpty">
<summary>
 A useful shortcut for Set.isEmpty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Count">
<summary>
 Return the number of elements in the set
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Choose">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Union(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Singleton(`1,`0)">
<summary>
 A singleton set based on the given comparison operator
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Remove(`0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Build two new sets, one containing the elements for which the given predicate returns &apos;true&apos;,
 and the other the remaining elements.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the collection
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSupersetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSubsetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Intersection(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &lt;c&gt;j0...jN&lt;/c&gt; then 
 computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0)">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Equality(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares two sets and returns true if they are equal or false otherwise
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Empty(`1)">
<summary>
 The empty set based on the given comparer
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Difference(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Create(`1,System.Collections.Generic.IEnumerable{`0})">
<summary>
 A set based on the given comparer containing the given initial elements
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Contains(`0)">
<summary>
 A useful shortcut for Set.contains.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Compare(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b        
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Add(`0)">
<summary>
 A useful shortcut for Set.add.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Set`2">
<summary>
 Immutable sets based on binary trees, default tag
 Immutable sets where a constraint tag carries information about the class of key-comparer being used.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Internal.Utilities.FSharpEnvironment.DotNetBuildString">
<summary>
 The F# version reported in the banner
</summary>
</member>
<member name="M:Internal.Utilities.FSharpEnvironment.Option.ofString(System.String)">
<summary>
 Convert string into Option string where null and String.Empty result in None
</summary>
</member>
<member name="T:Internal.Utilities.FSharpEnvironment.Option">

</member>
<member name="T:Internal.Utilities.FSharpEnvironment">

</member>
<member name="M:Internal.Utilities.Filename.fileNameWithoutExtension(System.String)">
<summary>
 Get the filename without extenstion of the given path
</summary>
</member>
<member name="M:Internal.Utilities.Filename.fileNameOfPath(System.String)">
<summary>
 Get the filename of the given path
</summary>
</member>
<member name="M:Internal.Utilities.Filename.hasExtension(System.String)">
<summary>
 Return true if the filename has a &quot;.&quot; extension
</summary>
</member>
<member name="M:Internal.Utilities.Filename.directoryName(System.String)">
<summary>
 &quot;directoryName&quot; &quot; decomposes a filename into a directory name
</summary>
</member>
<member name="M:Internal.Utilities.Filename.chopExtension(System.String)">
<summary>
 &quot;chopExtension f&quot; removes the extension from the given
 filename. Raises ArgumentException if no extension is present.
</summary>
</member>
<member name="M:Internal.Utilities.Filename.checkSuffix(System.String,System.String)">
<summary>
 &quot;checkSuffix f s&quot; returns true if filename &quot;f&quot; ends in suffix &quot;s&quot;,
 e.g. checkSuffix &quot;abc.fs&quot; &quot;.fs&quot; returns true.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Filename">
<summary>
 Some filename operations.    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.FlatListModule">

</member>
<member name="M:Internal.Utilities.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.singleton``1(``0)">
<summary>
 Return an array containing the given element
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofArray``1(``0[])">
<summary>
 Build a ResizeArray from the given elements
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input ResizeArray
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns &quot;Some(x)&quot; for some x.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Return None if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &quot;x&quot; for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;
respectively 
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Internal.Utilities.ResizeArrayModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.StructuredFormat.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 &lt;example&gt;
 From F# Interactive the default settings can be adjusted using, for example, 
 &lt;pre&gt;
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 &lt;/pre&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="P:Internal.Utilities.StructuredFormat.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:Internal.Utilities.StructuredFormat.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for 
 list-like structures, or columns in table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation 
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.StructuredFormat.Layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.StructuredFormat.Joint">
<summary>
 Data representing structured layouts of terms.  
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.StructuredFormat.Display.layout_to_string(Internal.Utilities.StructuredFormat.FormatOptions,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.StructuredFormat.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the &quot;[1;2]&quot; notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="T:Internal.Utilities.StructuredFormat.Display">

</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc{``0,Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}},Internal.Utilities.StructuredFormat.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.aboveL(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.braceL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.squareBracketL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.bracketL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.sepListL(Internal.Utilities.StructuredFormat.Layout,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_AtAtMinusMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_AtAtMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_AtAt(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_MinusMinusMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_MinusMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_PlusPlus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_HatHat(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.isEmptyL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Internal.Utilities.StructuredFormat.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Internal.Utilities.StructuredFormat.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Interpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by fslex. 
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Lexing.UnicodeTables">
<summary>
 The type of tables for an unicode lexer generated by fslex. 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.Lexeme">
<summary>
 The matched string 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.BufferLocalStore">
<summary>
 Dynamically typed, non-lexically scoped parameter table
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeString(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Fast helper to turn the matched characters into a string, avoiding an intermediate array
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromFunction(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0[],System.Int32,System.Int32},System.Int32})">
<summary>
 Create a lex buffer that reads character or byte inputs by using the given function
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromChars(System.Char[])">
<summary>
 Create a lex buffer suitable for Unicode lexing that reads characters from the given array
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.LexBuffer`1">
<summary>
 Input buffers consumed by lexers generated by &lt;c&gt;fslex.exe &lt;/c&gt;
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.StartOfLineAbsoluteOffset">
<summary>
 Return absolute offset of the start of the line marked by the position
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.OriginalLine">
<summary>
 The line number for the position in the input stream, assuming fresh positions have been updated 
 using for the new line
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Line">
<summary>
 The line number in the input stream, assuming fresh positions have been updated 
 for the new line by modifying the EndPos property of the LexBuffer.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.FileIndex">
<summary>
 The file index for the file associated with the input stream, use fileOfFileIndex in range.fs to decode
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Empty">
<summary>
 Get an arbitrary position, with the empty string as filename, and  
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Column">
<summary>
 Return the column number marked by the position, i.e. the difference between the AbsoluteOffset and the StartOfLineAbsoluteOffset
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.AbsoluteOffset">
<summary>
 The character number in the input stream
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ShiftColumnBy(System.Int32)">
<summary>
 Gives a position shifted by specified number of characters
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.EndOfToken(System.Int32)">
<summary>
 Given a position at the start of a token of length n, return a position just beyond the end of the token
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ApplyLineDirective(System.Int32,System.Int32)">
<summary>
 Apply a #line directive
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.tagOfErrorTerminal">
<summary>
 The tag of the error terminal
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.numTerminals">
<summary>
 The total number of terminals 
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.parseError">
<summary>
 This function is used to hold the user specified &quot;parse_error&quot; or &quot;parse_error_rich&quot; functions
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.productionToNonTerminalTable">
<summary>
 This table is logically part of the Goto table
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableRowOffsets">
<summary>
 The sparse table offsets for the productions active for each state
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableElements">
<summary>
 The sparse table for the productions active for each state
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.sparseGotoTableRowOffsets">
<summary>
 The sparse goto table row offsets
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.gotos">
<summary>
 The sparse goto table
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.immediateActions">
<summary>
 The immediate action table
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.reductionSymbolCounts">
<summary>
 The number of symbols for each reduction
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.actionTableRowOffsets">
<summary>
 The sparse action table row offsets
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.actionTableElements">
<summary>
 The sparse action table elements
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.dataOfToken">
<summary>
 A function to compute the data carried by a token
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.tagOfToken">
<summary>
 A function to compute the tag of a token
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.endOfInputTag">
<summary>
 The token number indicating the end of input
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.reductions">
<summary>
 The reduction table
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.Tables`1.Interpret(Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},`0},Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32)">
<summary>
 Interpret the parser table taking input from the given lexer, using the given lex buffer, and the given start state.
 Returns an object indicating the final synthesized value for the parse.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.Tables`1">
<summary>
 Tables generated by fsyacc
 The type of the tables contained in a file produced by the fsyacc.exe parser generator.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.StateStack">
<summary>
 The stack of state indexes active at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ShiftTokens">
<summary>
 The token that would cause a shift at the parse error
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReducibleProductions">
<summary>
 The stack of productions that would be reduced at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReduceTokens">
<summary>
 The tokens that would cause a reduction at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ParseState">
<summary>
 The state active at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.Message">
<summary>
 The message associated with the parse error
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.CurrentToken">
<summary>
 The token that caused the parse error
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseErrorContext`1">
<summary>
 The context provided when a parse error occurs
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultStartPosition">
<summary>
 Get the start of the range of positions matched by the production
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultRange">
<summary>
 Get the full range of positions matched by the production
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultEndPosition">
<summary>
 Get the end of the range of positions matched by the production
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.LexBuffer">
<summary>
 Return the LexBuffer for this parser instance
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.RaiseError``1">
<summary>
 Raise an error in this parse context
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputStartPosition(System.Int32)">
<summary>
 Get the start position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputRange(System.Int32)">
<summary>
 Get the start and end position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputEndPosition(System.Int32)">
<summary>
 Get the end position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.GetInput(System.Int32)">
<summary>
 Get the value produced by the terminal or non-terminal at the given position
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Parsing.RecoverableParseError">
<summary>
 Indicates a parse error has occured and parse recovery is in progress
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Parsing.Accept">
<summary>
 Indicates an accept action has occured
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error(System.String)">
<summary>
 The default implementation of the parse_error function
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error_rich``1">
<summary>
 The default implementation of the parse_error_rich function
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseHelpers">
<summary>
 Helpers used by generated parsers.
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Parsing.Flags">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LayeredMap`2.LinearTryModifyThenLaterFlatten(`0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{`1},`1})">
<summary>
 Push an item that transforms a possible existing entry. This is used for the bulk updates
 in nameres.fs, where, for each type we push during an &quot;open&quot;, we must combine the
 type with any existing entries for types in the eUnqualifiedItems table. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LayeredMap`2">
<summary>
 Immutable map collection, with explicit flattening to a backing dictionary 

 A layered map is still an immutable map containing a &quot;front&quot; 
 F# Map, but the layered map collapses its treeMap to a &quot;backing&quot;
 dictionary at specific &quot;add-and-tryCollapseToDictAndNothingElse&quot; points. 

 For maps built from multiple &quot;add-and-tryCollapseToDictAndNothingElse&quot; operations,
 the process of building the collapsed maps is coalesced.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2.findOriginalException">
<summary>
 A helper to ensure we rethrow the &quot;original&quot; exception
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2.funcOrException">
<summary>
 This field holds either the function to run or a LazyWithContextFailure object recording the exception raised 
 from running the function. It is null if the thunk has been evaluated successfully.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2.value">
<summary>
 This field holds the result of a successful computation. It&apos;s initial value is Unchecked.defaultof
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2">
<summary>
 Just like &quot;Lazy&quot; but EVERY forcer must provide an instance of &quot;ctxt&quot;, e.g. to help track errors
 on forcing back to at least one sensible user location
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually`1">
<summary>
 Computations that can cooperatively yield by returning a continuation

    - Any yield of a NotYetDone should typically be &quot;abandonable&quot; without adverse consequences. No resource release
      will be called when the computation is abandoned.

    - Computations suspend via a NotYetDone may use local state (mutables), where these are
      captured by the NotYetDone closure. Computations do not need to be restartable.

    - The key thing is that you can take an Eventually value and run it with 
      Eventually.repeatedlyProgressUntilDoneOrTimeShareOver
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.getHole``1(Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Get an initialization hole 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Shim.FileSystem.SafeGetFullPath(System.String)">
<summary>
 Take in a filename with an absolute path, and return the same filename
 but canonicalized with respect to extra path separators (e.g. C:\\\\foo.txt) 
 and &apos;..&apos; portions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Shim">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.MultiMapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMultiMapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMapModule">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Tables">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.EventuallyModule.repeatedlyProgressUntilDoneOrTimeShareOver``1(System.Int64,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0}},Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0}},Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0})">
<summary>
 Keep running the computation bit by bit until a time limit is reached.
 The runner gets called each time the computation is restarted
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.EventuallyModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.FlatList">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Map">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.ListSet">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Lazy">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.HashsetModule">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Dictionary">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.String">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.List.FrontAndBack">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Array">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Order">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library">

</member>
</members>
</doc>
