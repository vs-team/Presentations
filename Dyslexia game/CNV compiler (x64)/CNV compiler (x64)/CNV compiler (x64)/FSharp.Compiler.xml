<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Compiler</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.QueueList`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Note this operation is O(n) anyway, so executing ToFlatList() here is OK
</summary>
</member>
<member name="M:Internal.Utilities.QueueList`1.AppendOne(`0)">
<summary>
 Note this operation is O(1), unless a push happens, which is rare 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.QueueList`1">
<summary>
 Iterable functional collection with O(1) append-1 time. Useful for data structures where elements get added at the
 end but the collection must occadionally be iterated. Iteration is slower and may allocate because 
 a suffix of elements is stored in reverse order.

 The type doesn&apos;t support structural hashing or comparison.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Debug.TraceInterop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.QueueListModule">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tainted`1.TypeProviderDesignation">
<summary>
 Test to report for the name of the type provider that produced the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tainted`1.TypeProviderAssemblyRef">
<summary>
 The ILScopeRef of the runtime assembly reference for type provider that produced the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tainted`1.TypeProvider">
<summary>
 A type provider that produced the value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PUntaintNoFailure``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply an operation and &apos;untaint&apos; the result. This can be used if the return type 
 is guaranteed not to be implemented by a type provider
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PUntaint``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation and &apos;untaint&apos; the result. The result must be marshalable. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyWithProvider``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0,Microsoft.FSharp.Core.CompilerServices.ITypeProvider},``0},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyOption``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation that returns an option. Unwrap option. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyNoFailure``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply an operation. No exception may be raised by &apos;f&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyArray``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0[]},System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation that returns an array. Unwrap array. Any exception will be attributed to the type provider with an error located at the given range.  String is method name of thing-returning-array, to diagnostically attribute if it is null
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply4``4(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1,``2,``3}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply3``3(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1,``2}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply2``2(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.OfType``1">
<summary>
 Conditionally coerce the value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.CreateAll(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.CompilerServices.ITypeProvider,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef}})">
<summary>
 Create an initial tainted value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.Coerce``1(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Assert that the value is of &apos;U and coerce the value.
 If corecion fails, the failuer will be blamed on a type provider
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tainted`1">
<summary>
 This struct wraps a value produced by a type provider to properly attribute any failures.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.WithContext(System.String,System.String)">
<summary>
 creates new instance of TypeProviderError with specified type\method names
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.MapText(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.String}},System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 creates new instance of TypeProviderError based on current instance information(message)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.Iter(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.TypeProviderError,Microsoft.FSharp.Core.Unit})">
<summary>
 provides uniform way to process aggregated errors
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.#ctor(System.Int32,System.String,Microsoft.FSharp.Compiler.Range.range,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 creates new instance of TypeProviderError that represents collection of errors
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.#ctor(System.Tuple{System.Int32,System.String},System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 creates new instance of TypeProviderError that represents one error
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.TypeProviderError">
<summary>
 Stores and transports aggregated list of errors reported by the type provider
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiLexer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiParser.SigArg">
<summary>
 vararg sentinels
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiParser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiParser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.StableNiceNameGenerator">
<summary>
 Generates compiler-generated names marked up with a source code location, but if given the same unique value then
 return precisely the same name. Each name generated also includes the StartLine number of the range passed in
 at the point of first generation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.NiceNameGenerator">
<summary>
 Generates compiler-generated names. Each name generated also includes the StartLine number of the range passed in
 at the point of first generation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LexerWhitespaceContinuation">
<summary>
 The parser defines a number of tokens for whitespace and
 comments eliminated by the lexer.  These carry a specification of
 a continuation for the lexer for continued processing after we&apos;ve dealt with
 the whitespace.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LexerEndlineContinuation">
<summary>
 Specifies how the &apos;endline&apos; function in the lexer should continue after
 it reaches end of line or eof. The options are to continue with &apos;token&apos; function
 or to continue with &apos;skip&apos; function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynReturnInfo">
<summary>
 The syntactic elements associated with the &quot;return&quot; of a function or method. Some of this is
 mostly dummy information to make the return element look like an argument,
 the important thing is that (a) you can give a return type for the function or method, and 
 (b) you can associate .NET attributes to return of a function or method and these get stored in .NET metadata.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.QualifiedNameOfFile">
<summary>
 ImplFile(modname,isScript,qualName,hashDirectives,modules,isLastCompiland)
 QualifiedNameOfFile acts to fully-qualify module specifications and implementations, 
 most importantly the ones that simply contribute fragments to a namespace (i.e. the ParsedSigFileFragment.NamespaceFragment case) 
 There may be multiple such fragments in a single assembly.  There may thus also 
 be multiple matching pairs of these in an assembly, all contributing types to the same 
 namespace. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynModuleOrNamespace">
<summary>
 SynModuleOrNamespace(lid,isModule,decls,xmlDoc,attribs,SynAccess,m)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.AutoProperty">
<summary>
 SynMemberDefn.AutoProperty (attribs,isStatic,id,tyOpt,propKind,memberFlags,xmlDoc,access,synExpr,mGetSet,mWholeAutoProp).
 
 F# syntax: &apos;member val X = expr&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.NestedType">
<summary>
 A feature that is not implemented
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.LetBindings">
<summary>
 LetBindings(bindingList, isStatic, isRecursive, wholeRange)

 localDefns 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.ImplicitInherit">
<summary>
 inherit &lt;typ&gt;(args...) as base 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.ImplicitCtor">
<summary>
 implicit ctor args as a defn line, &apos;as&apos; specification 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExceptionDefn">
<summary>
 &apos;exception E = ... with ...&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExceptionRepr">
<summary>
 &apos;exception E = ... &apos;
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynValTyparDecls">
<summary>
 The names and other metadata for the type parameters for a member or function
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynArgInfo">
<summary>
 The argument names and other metadata for a parameter for a member or function
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynValInfo.SynValInfo">
<summary>
 SynValInfo(curriedArgInfos, returnInfo)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynValInfo">
<summary>
 The argument names and other metadata for a member or function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynComponentInfo">
<summary>
 The untyped, unchecked syntax tree associated with the name of a type definition or module
 in signature or implementation. 

 THis includes the name, attributes, type parameters, constraints, documentation and accessibility 
 for a type definition or module. For modules, entries such as the type parameters are
 always empty.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynField">
<summary>
 The untyped, unchecked syntax tree for a field declaration in a record or class
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSig.TypeDefnSig">
<summary>
 The information for a type definition in a signature
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSig">
<summary>
 The untyped, unchecked syntax tree for a type definition in a signature
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSigRepr.Simple">
<summary>
 Indicates the right right-hand-side is a record, union or other simple type. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSigRepr.ObjectModel">
<summary>
 Indicates the right right-hand-side is a class, struct, interface or other object-model type
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSigRepr">
<summary>
 The untyped, unchecked syntax tree for the right-hand-side of a type definition in a signature.
 Note: in practice, using a discriminated union to make a distinction between 
 &quot;simple&quot; types and &quot;object oriented&quot; types is not particularly useful.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCaseType.UnionCaseFullType">
<summary>
 Full type spec given by &apos;UnionCase : ty1 * tyN -&gt; rty&apos;. Only used in FSharp.Core, otherwise a warning.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCaseType.UnionCaseFields">
<summary>
 Normal style declaration 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCaseType">
<summary>
 The untyped, unchecked syntax tree for the right-hand-side of union definition, excluding members,
 in either a signature or implementation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCase.UnionCase">
<summary>
 The untyped, unchecked syntax tree for one case in a union definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynEnumCase.EnumCase">
<summary>
 The untyped, unchecked syntax tree for one case in an enum definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.None">
<summary>
 An abstract definition , &quot;type X&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.TypeAbbrev">
<summary>
 A type abbreviation, &quot;type X = A.B.C&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.LibraryOnlyILAssembly">
<summary>
 A type defined by using an IL assembly representation. Only used in FSharp.Core.
 
 F# syntax: &quot;type X = (# &quot;...&quot;#)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.General">
<summary>
 An object oriented type definition. This is not a parse-tree form, but represents the core
 type representation which the type checker splits out from the &quot;ObjectModel&quot; cases of type definitions.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.Record">
<summary>
 A record type definition, type X = { A : int; B : int }
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.Enum">
<summary>
 An enum type definition, type X = A = 1 | B = 2
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.Union">
<summary>
 A union type definition, type X = A | B
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr">
<summary>
 The untyped, unchecked syntax tree for the core of a simple type definition, in either signature
 or implementation. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberSig">
<summary>
 The untyped, unchecked syntax tree for a member signature, used in signature files, abstract member declarations
 and member constraints.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.MemberKind.PropertyGetSet">
<summary>
 An artifical member kind used prior to the point where a get/set property is split into two distinct members.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.MemberKind">
<summary>
 Note the member kind is actually computed partially by a syntax tree transformation in tc.fs
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ast.SynAttribute.AppliesToGetterAndSetter">
<summary>
 Is this attribute being applied to a property getter or setter?
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ast.SynAttribute.Target">
<summary>
 Target specifier, e.g. &quot;assembly&quot;,&quot;module&quot;,etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.FromParseError">
<summary>
 A pattern arising from a parse error
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.InstanceMember">
<summary>
 Used internally in the type checker
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.DeprecatedCharRange">
<summary>
 Deprecated character ranges
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.QuoteExpr">
 <@ expr @>, used for active pattern arguments
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.IsInst">
<summary>
 &apos;:? type &apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.OptionalVal">
<summary>
 &apos;?id&apos; -- for optional argument names
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.Null">
<summary>
 &apos;null&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePats">
<summary>
 Represents a simple set of variable bindings a, (a,b) or (a:Type,b:Type) at a lambda,
 function definition or other binding point, after the elimination of pattern matching
 from the construct, e.g. after changing a &quot;function pat1 -&gt; rule1 | ...&quot; to a 
 &quot;fun v -&gt; match v with ...&quot;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePatAlternativeIdInfo.Decided">
<summary>
 We have decided to use an alternative name in tha pattern and related expression 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePatAlternativeIdInfo.Undecided">
<summary>
 We have not decided to use an alternative name in tha pattern and related expression 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePat.Id">
<summary>
 Id (ident, altNameRefCell, isCompilerGenerated, isThisVar, isOptArg, range)

 Indicates a simple pattern variable.

   altNameRefCell 
     Normally &apos;None&apos; except for some compiler-generated variables in desugaring pattern matching. 
     Pattern processing sets this reference for hidden variable introduced by desugaring pattern matching in arguments.
     The info indicates an alternative (compiler generated) identifier to be used because the name of the identifier is already bound.
     See Product Studio FSharp 1.0, bug 6389.

   isCompilerGenerated : true if a compiler generated name 
   isThisVar: true if &apos;this&apos; variable in member  
   isOptArg: true if a &apos;?&apos; is in front of the name
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DiscardAfterMissingQualificationAfterDot">
<summary>
 Inserted for error recovery when there is &quot;expr.&quot; and missing tokens or error recovery after the dot
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.FromParseError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ArbitraryAfterError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyUnionCaseFieldSet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyUnionCaseFieldGet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyStaticOptimization">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyILAssembly">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DoBang">
<summary>
 F# syntax: do! expr 
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LetOrUseBang">
<summary>
 SynExpr.LetOrUseBang(spBind, isUse, isFromSource, pat, rhsExpr, bodyExpr, mWholeExpr).

 F# syntax: let! pat = expr in expr
 F# syntax: use! pat = expr in expr
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.YieldOrReturnFrom">
<summary>
 F# syntax: yield! expr 
 F# syntax: return! expr 
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.YieldOrReturn">
<summary>
 F# syntax: yield expr 
 F# syntax: return expr 
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ImplicitZero">
<summary>
 F# syntax: &lt;implicit&gt;
 Computation expressions only, implied by final &quot;do&quot; or &quot;do!&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.JoinIn">
<summary>
 F# syntax: ... in ... 
 Computation expressions only, based on JOIN_IN token from lex filter
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TraitCall">
<summary>
 F# syntax: ((typar1 or ... or typarN): (member-dig) expr)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.AddressOf">
<summary>
 F# syntax: &amp;expr, &amp;&amp;expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Null">
<summary>
 F# syntax: null
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.InferredDowncast">
<summary>
 F# syntax: downcast expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.InferredUpcast">
<summary>
 F# syntax: upcast expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Downcast">
<summary>
 F# syntax: expr :?&gt; type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Upcast">
<summary>
 F# syntax: expr :&gt; type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TypeTest">
<summary>
 F# syntax: expr :? type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotNamedIndexedPropertySet">
<summary>
 F# syntax: expr.Items(e1) &lt;- e2 , rarely used named-property-setter notation, e.g. (stringExpr).Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.NamedIndexedPropertySet">
<summary>
 F# syntax: Type.Items(e1) &lt;- e2 , rarely used named-property-setter notation, e.g. Foo.Bar.Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotIndexedSet">
<summary>
 DotIndexedSet (objectExpr, indexExprs, valueExpr, rangeOfLeftOfSet, rangeOfDot, rangeOfWholeExpr)

 F# syntax: expr.[expr,...,expr] &lt;- expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotIndexedGet">
<summary>
 F# syntax: expr.[expr,...,expr] 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotSet">
<summary>
 F# syntax: expr.ident...ident &lt;- expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotGet">
<summary>
 DotGet(expr, rangeOfDot, lid, wholeRange)

 F# syntax: expr.ident.ident
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LongIdentSet">
<summary>
 F# syntax: ident.ident...ident &lt;- expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LongIdent">
<summary>
 F# syntax: ident.ident...ident
 LongIdent(isOptional, longIdent, altNameRefCell, m)
   isOptional: true if preceded by a &apos;?&apos; for an optional named parameter 
   altNameRefCell: Normally &apos;None&apos; except for some compiler-generated variables in desugaring pattern matching. See SynSimplePat.Id
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Ident">
<summary>
 F# syntax: ident
 Optimized representation, = SynExpr.LongIdent(false,[id],id.idRange) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.IfThenElse">
<summary>
  IfThenElse(exprGuard,exprThen,optionalExprElse,spIfToThen,isFromErrorRecovery,mIfToThen,mIfToEndOfLastBranch)

 F# syntax: if expr then expr
 F# syntax: if expr then expr else expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Sequential">
<summary>
 Seq(seqPoint, isTrueSeq, e1, e2, m)
  isTrueSeq: false indicates &quot;let v = a in b; v&quot; 

 F# syntax: expr; expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Lazy">
<summary>
 F# syntax: lazy expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TryFinally">
<summary>
 F# syntax: try expr finally expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TryWith">
<summary>
 F# syntax: try expr with pat -&gt; expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LetOrUse">
<summary>
 LetOrUse(isRecursive, isUse, bindings, body, wholeRange)

 F# syntax: let pat = expr in expr 
 F# syntax: let f pat1 .. patN = expr in expr 
 F# syntax: let rec f pat1 .. patN = expr in expr 
 F# syntax: use pat = expr in expr 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TypeApp">
<summary>
 TypeApp(expr, mLessThan, types, mCommas, mGreaterThan, mTypeArgs, mWholeExpr) 
     &quot;mCommas&quot; are the ranges for interstitial commas, these only matter for parsing/design-time tooling, the typechecker may munge/discard them

 F# syntax: expr&lt;type1,...,typeN&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.App">
<summary>
 App(exprAtomicFlag, isInfix, funcExpr, argExpr, m)
  - exprAtomicFlag: indicates if the applciation is syntactically atomic, e.g. f.[1] is atomic, but &apos;f x&apos; is not
  - isInfix is true for the first app of an infix operator, e.g. 1+2 becomes App(App(+,1),2), where the inner node is marked isInfix 
      (or more generally, for higher operator fixities, if App(x,y) is such that y comes before x in the source code, then the node is marked isInfix=true)

 F# syntax: f x
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Assert">
<summary>
 F# syntax: assert expr 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Do">
<summary>
 F# syntax: do expr 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Match">
<summary>
 F# syntax: match expr with pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.MatchLambda">
<summary>
 F# syntax: function pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Lambda">
<summary>
 First bool indicates if lambda originates from a method. Patterns here are always &quot;simple&quot; 
 Second bool indicates if this is a &quot;later&quot; part of an iterated sequence of lambdas

 F# syntax: fun pat -&gt; expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.CompExpr">
<summary>
 CompExpr(isArrayOrList, isNotNakedRefCell, expr)

 F# syntax: { expr }
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ArrayOrListOfSeqExpr">
<summary>
 F# syntax: [ expr ], [| expr |]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ForEach">
<summary>
 SynExpr.ForEach (spBind, seqExprOnly, isFromSource, pat, enumExpr, bodyExpr, mWholeExpr).

 F# syntax: &apos;for ... in ... do ...&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.For">
<summary>
 F# syntax: &apos;for i = ... to ... do ...&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.While">
<summary>
 F# syntax: &apos;while ... do ...&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ObjExpr">
<summary>
 SynExpr.ObjExpr(objTy,argOpt,binds,extraImpls,mNewExpr,mWholeExpr)

 F# syntax: { new ... with ... }
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.New">
<summary>
 F# syntax: new C(...)
 The flag is true if known to be &apos;family&apos; (&apos;protected&apos;) scope 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Record">
<summary>
 F# syntax: { f1=e1; ...; fn=en }
 SynExpr.Record((baseType, baseCtorArgs, mBaseCtor, sepAfterBase, mInherits), (copyExpr, sepAfterCopyExpr), (recordFieldName, fieldValue, sepAfterField), mWholeExpr)
 inherit includes location of separator (for tooling) 
 copyOpt contains range of the following WITH part (for tooling)
 every field includes range of separator after the field (for tooling)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ArrayOrList">
<summary>
 F# syntax: [ e1; ...; en ], [| e1; ...; en |]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Tuple">
<summary>
 F# syntax: e1, ..., eN
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Typed">
<summary>
 F# syntax: expr : type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Const">
<summary>
 F# syntax: 1, 1.3, () etc.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Quote">
<summary>
 F# syntax: &lt;@ expr @&gt;, &lt;@@ expr @@&gt;
 
 Quote(operator,isRaw,quotedSynExpr,isFromQueryExpression,m)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Paren">
<summary>
 F# syntax: (expr)

 Paren(expr, leftParenRange, rightParenRange, wholeRangeIncludingParentheses)

 Parenthesized expressions. Kept in AST to distinguish A.M((x,y)) 
 from A.M(x,y), among other things.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynExpr.RangeSansAnyExtraDot">
<summary>
 range ignoring any (parse error) extra trailing dots
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynExpr.RangeOfFirstPortion">
<summary>
 Attempt to get the range of the first token or initial portion only - this is extremely ad-hoc, just a cheap way to improve a certain &apos;query custom operation&apos; error range
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynExpr.Range">
<summary>
 Get the syntactic range of source code covered by this construct.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.StaticConstantNamed">
<summary>
 F# syntax : ident=1 etc., used in static parameters to type providers
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.StaticConstantExpr">
<summary>
 F# syntax : const expr, used in static parameters to type providers
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.StaticConstant">
<summary>
 F# syntax : 1, &quot;abc&quot; etc, used in parameters to type providers
 For the dimensionless units i.e. 1 , and static parameters to provided types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.MeasurePower">
<summary>
 F# syntax : for units of measure e.g. m^3 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.MeasureDivide">
<summary>
 F# syntax : for units of measure e.g. m / s 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.HashConstraint">
<summary>
 F# syntax : #type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.WithGlobalConstraints">
<summary>
 F# syntax : typ with constraints
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Anon">
<summary>
 F# syntax : _
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Var">
<summary>
 F# syntax : &apos;Var
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Fun">
<summary>
 F# syntax : type -&gt; type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Array">
<summary>
 F# syntax : type[]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Tuple">
<summary>
 F# syntax : type * ... * type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.LongIdentApp">
<summary>
 LongIdentApp(typeName, longId, LESSm, tyArgs, commasm, GREATERm, wholem)

 F# syntax : type.A.B.C&lt;type, ..., type&gt;
   commasm: ranges for interstitial commas, these only matter for parsing/design-time tooling, the typechecker may munge/discard them
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.App">
<summary>
 App(typeName, LESSm, typeArgs, commasm, GREATERm, isPostfix, m)

 F# syntax : type&lt;type, ..., type&gt; or type type or (type,...,type) type
   isPostfix: indicates a postfix type application e.g. &quot;int list&quot; or &quot;(int,string) dict&quot;
   commasm: ranges for interstitial commas, these only matter for parsing/design-time tooling, the typechecker may munge/discard them
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.LongIdent">
<summary>
 F# syntax : A.B.C
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynType.Range">
<summary>
 Get the syntactic range of source code covered by this construct.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType">
<summary>
 The unchecked abstract syntax tree of F# types 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsDelegate">
<summary>
 F# syntax is &apos;typar : delegate&lt;&apos;Args,unit&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsEnum">
<summary>
 F# syntax is &apos;typar : enum&lt;&apos;UnderlyingType&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparSupportsMember">
<summary>
 F# syntax is ^T : (static member MemberName : ^T * int -&gt; ^T) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparSubtypeOfType">
<summary>
 F# syntax is &apos;typar :&gt; type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparDefaultsToType">
<summary>
 F# syntax is default ^T : type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsEquatable">
<summary>
 F# syntax is &apos;typar : equality
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsComparable">
<summary>
 F# syntax is &apos;typar : comparison 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparSupportsNull">
<summary>
 F# syntax is &apos;typar : null
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsUnmanaged">
<summary>
 F# syntax is &apos;typar : unmanaged
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsReferenceType">
<summary>
 F# syntax : is &apos;typar : not struct
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsValueType">
<summary>
 F# syntax : is &apos;typar : struct
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint">
<summary>
 The unchecked abstract syntax tree of F# type constraints
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTyparDecl">
<summary>
 Represents the explicit declaration of a type parameter
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind.DoBinding">
<summary>
 A &apos;do&apos; binding in a module. Must have type &apos;unit&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind.NormalBinding">
<summary>
 A normal &apos;let&apos; binding in a module
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind.StandaloneExpression">
<summary>
 A standalone expression in a module
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind">
<summary>
 The kind associated with a binding - &quot;let&quot;, &quot;do&quot; or a standalone expression
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ast.ExprAtomicFlag.Atomic">
<summary>
 Says that the expression is an atomic expression, i.e. is of a form that has no whitespace unless 
 enclosed in parantheses, e.g. 1, &quot;3&quot;, ident, ident.[expr] and (expr). If an atomic expression has
 type T, then the largest expression ending at the same range as the atomic expression also has type T.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.RecordFieldName">
<summary>
 stores pair: record field name + (true if given record field name is syntactically correct and can be used in name resolution)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.BlockSeparator">
<summary>
 denotes location of the separator block + optional position of the semicolon (used for tooling support)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SeqExprOnly">
<summary>
 Indicates if a for loop is &apos;for x in e1 -&gt; e2&apos;, only valid in sequence expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMeasure">
<summary>
 The unchecked abstract syntax tree of F# unit of measure annotaitons. 
 This should probably be merged with the represenation of SynType.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Measure">
<summary>
 Old comment: &quot;we never iterate, so the const here is not another SynConst.Measure&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt16s">
<summary>
 Used internally in the typechecker once an array of unit16 contants 
 is detected, to allow more efficient processing of large arrays of uint16 constants. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Bytes">
<summary>
 F# syntax: verbatim or regular byte string, e.g. &quot;abc&quot;B.

 Also used internally in the typechecker once an array of unit16 contants 
 is detected, to allow more efficient processing of large arrays of uint16 constants. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.String">
<summary>
 F# syntax: verbatim or regular string, e.g. &quot;abc&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UserNum">
<summary>
 UserNum(value, suffix)

 F# syntax: 1Q, 1Z, 1R, 1N, 1G
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Decimal">
<summary>
 F# syntax: 23.4M
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Char">
<summary>
 F# syntax: &apos;a&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Double">
<summary>
 F# syntax: 1.30, 1.40e10 etc.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Single">
<summary>
 F# syntax: 1.30f, 1.40e10f etc.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UIntPtr">
<summary>
 F# syntax: 13un
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.IntPtr">
<summary>
 F# syntax: 13n
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt64">
<summary>
 F# syntax: 13UL
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Int64">
<summary>
 F# syntax: 13L
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt32">
<summary>
 F# syntax: 13u, 0x4000u, 0o0777u
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Int32">
<summary>
 F# syntax: 13, 0x4000, 0o0777
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt16">
<summary>
 F# syntax: 13us, 0x4000us, 0o0777us, 0b0111101us
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Int16">
<summary>
 F# syntax: 13s, 0x4000s, 0o0777s, 0b0111101s
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Byte">
<summary>
 F# syntax: 13uy, 0x40uy, 0oFFuy, 0b0111101uy
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.SByte">
<summary>
 F# syntax: 13y, 0xFFy, 0o077y, 0b0111101y
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Bool">
<summary>
 F# syntax: true, false
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Unit">
<summary>
 F# syntax: ()
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst">
<summary>
 The unchecked abstract syntax tree of constants in F# types and expressions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LongIdentWithDots.LongIdentWithDots">
<summary>
 LongIdentWithDots(lid, dotms)   
 Typically dotms.Length = lid.Length-1, but they may be same if (incomplete) code ends in a dot, e.g. &quot;Foo.Bar.&quot;
 The dots mostly matter for parsing, and are typically ignored by the typechecker, but 
 if dotms.Length = lid.Length, then the parser must have reported an error, so the typechecker is allowed
 more freedom about typechecking these expressions.
 LongIdent can be empty list - it is used to denote that name of some AST element is absent (i.e. empty type name in inherit)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.XmlDocCollector">
<summary>
 Used to collect XML documentation during lexing and parsing.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.rhs(Internal.Utilities.Text.Parsing.IParseState,System.Int32)">
<summary>
 Get the range corresponding to one of the r.h.s. symbols of a grammar rule while it is being reduced
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.rhs2(Internal.Utilities.Text.Parsing.IParseState,System.Int32,System.Int32)">
<summary>
 Get the range covering two of the r.h.s. symbols of a grammar rule while it is being reduced
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.lhs(Internal.Utilities.Text.Parsing.IParseState)">
<summary>
 Get the range corresponding to the result of a grammar rule while it is being reduced
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.mkSynRange(Internal.Utilities.Text.Lexing.Position,Internal.Utilities.Text.Lexing.Position)">
<summary>
 Get an F# compiler range from a lexer range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.posOfLexPosition(Internal.Utilities.Text.Lexing.Position)">
<summary>
 Get an F# compiler position from a lexer position
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.ParseAssemblyCodeType(System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Helper for parsing the inline IL fragments. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.ParseAssemblyCodeInstructions(System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Helper for parsing the inline IL fragments. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.PushCurriedPatternsToExpr(Microsoft.FSharp.Compiler.Ast.SynArgNameGenerator,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynPat},Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 &quot;fun (UnionCase x) (UnionCase y) -&gt; body&quot; 
       ==&gt; 
   &quot;fun tmp1 tmp2 -&gt; 
        let (UnionCase x) = tmp1 in 
        let (UnionCase y) = tmp2 in 
        body&quot; 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SimplePatOfPat(Microsoft.FSharp.Compiler.Ast.SynArgNameGenerator,Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Push non-simple parts of a patten match over onto the r.h.s. of a lambda.
 Return a simple pattern and a function to build a match on the r.h.s. if the pattern is complex
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.|SynPatForNullaryArgs|_|(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Recognize the &apos;()&apos; in &apos;new()&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.|SynPatForConstructorDecl|_|(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Extract the argument for patterns corresponding to the declaration of &apos;new ... = ...&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.IsControlFlowExpression(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 This affects placement of sequence points
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.|LongOrSingleIdent|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Match a long identifier, including the case for single identifiers which gets a more optimized node in the syntax tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.FsiDynamicModulePrefix">
<summary>
 The prefix of the names used for the fake namespace path added to all dynamic code entries in FSI.EXE
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SyntaxError">
<summary>
 The error raised by the parse_error_rich function, which is called by the parser engine
 when a syntax error occurs. The first object is the ParseErrorContext which contains a dump of
 information about the grammar at the point where the error occured, e.g. what tokens
 are valid to shift next at that point in the grammar. This information is processed in build.fs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.LexbufLocalXmlDocStore.GrabXmlDocBeforeMarker(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Called from the parser each time we parse a construct that marks the end of an XML doc comment range,
 e.g. a &apos;type&apos; declaration. The markerRange is the range of the keyword that delimits the construct.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.LexbufLocalXmlDocStore.SaveXmlDocLine(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.String,Microsoft.FSharp.Compiler.Range.pos)">
<summary>
 Called from the lexer to save a single line of XML doc comment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LexbufLocalXmlDocStore">
<summary>
 XmlDoc F# lexer/parser state, held in the BufferLocalStore for the lexer.
 This is the only use of the lexer BufferLocalStore in the codebase.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynValData(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Ast.MemberFlags},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Ast.SynPat},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Ast.SynReturnInfo},Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Infer the syntactic information for a &apos;let&apos; or &apos;member&apos; definition, based on the argument pattern,
 any declared return information (e.g. .NET attributes on the return element), and the r.h.s. expression
 in the case of &apos;let&apos; definitions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferLambdaArgs(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 For &apos;let&apos; definitions, we infer syntactic argument information from the r.h.s. of a definition, if it
 is an immediate &apos;fun ... -&gt; ...&apos; or &apos;function ...&apos; expression. This is noted in the F# language specification.
 This does not apply to member definitions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AdjustMemberArgs``1(Microsoft.FSharp.Compiler.Ast.MemberKind,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Transform a property declared using &apos;[static] member P = expr&apos; to a method taking a &quot;unit&quot; argument.
 This is similar to IncorporateEmptyTupledArgForPropertyGetter, but applies to member definitions
 rather than member signatures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AdjustArgsForUnitElimination(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynArgInfo}})">
<summary>
 Make sure only a solitary unit argument has unit elimination
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynArgInfoFromPat(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Infer the syntactic argument info for one or more arguments a pattern.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynArgInfoFromSimplePats(Microsoft.FSharp.Compiler.Ast.SynSimplePats)">
<summary>
 Infer the syntactic argument info for one or more arguments one or more simple patterns.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynArgInfoFromSimplePat(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynAttribute},Microsoft.FSharp.Compiler.Ast.SynSimplePat)">
<summary>
 Infer the syntactic argument info for a single argument from a simple pattern.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AttribsOfArgData(Microsoft.FSharp.Compiler.Ast.SynArgInfo)">
<summary>
 Get the argument attributes from the syntactic information for an argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AritiesOfArgs(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Get the argument counts for each curried argument group. Used in some adhoc places in tc.fs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IncorporateSetterArg(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the value argument for a property setter. This is 
 used for the implicit value argument in property setter signature specifications.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IncorporateSelfArg(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;this&apos; argument. This is 
 used for the implicit &apos;this&apos; argument in member signature specifications.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IncorporateEmptyTupledArgForPropertyGetter(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;()&apos; argument to a property getter. This is 
 used for the implicit &apos;()&apos; argument in property getter signature specifications.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.HasOptionalArgs(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Check if there are any optional arguments in the syntactic argument information. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IsOptionalArg(Microsoft.FSharp.Compiler.Ast.SynArgInfo)">
<summary>
 Check if one particular argument is an optional argument. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.HasNoArgs(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Determine if a syntactic information represents a member without arguments (which is implicitly a property getter)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.selfMetadata">
<summary>
 The &apos;argument&apos; information for the &apos;this&apos;/&apos;self&apos; parameter in the cases where it is not given explicitly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unnamedRetVal">
<summary>
 The &apos;argument&apos; information for a return value where no attributes are given for the return value (the normal case)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unitArgData">
<summary>
 The argument information for a &apos;()&apos; argument
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unnamedTopArg">
<summary>
 The argument information for a curried argument without a name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unnamedTopArg1">
<summary>
 The argument information for an argument without a name
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynInfo">
<summary>
 Operations related to the syntactic analysis of arguments of value, function and member definitions and signatures.

 Function and member definitions have strongly syntactically constrained arities.  We infer
 the arity from the syntax.

 For example, we record the arity for: 
 StaticProperty --&gt; [1]               -- for unit arg
 this.InstanceProperty --&gt; [1;1]        -- for unit arg
 StaticMethod(args) --&gt; map InferSynArgInfoFromSimplePat args
 this.InstanceMethod() --&gt; 1 :: map InferSynArgInfoFromSimplePat args
 this.InstanceProperty with get(argpat) --&gt; 1 :: [InferSynArgInfoFromSimplePat argpat]
 StaticProperty with get(argpat) --&gt; [InferSynArgInfoFromSimplePat argpat]
 this.InstanceProperty with get() --&gt; 1 :: [InferSynArgInfoFromSimplePat argpat]
 StaticProperty with get() --&gt; [InferSynArgInfoFromSimplePat argpat]
 
 this.InstanceProperty with set(argpat)(v) --&gt; 1 :: [InferSynArgInfoFromSimplePat argpat; 1]
 StaticProperty with set(argpat)(v) --&gt; [InferSynArgInfoFromSimplePat argpat; 1]
 this.InstanceProperty with set(v) --&gt; 1 :: [1]
 StaticProperty with set(v) --&gt; [1] 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.CustomOperations">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.FSharpLib">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast">

</member>
<member name="M:Microsoft.FSharp.Compiler.Augment.TypeDefinitelyHasEquality(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 This predicate can be used once type inference is complete, before then it is an approximation
 that doesn&apos;t assert any new constraints
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Augment">
<summary>
 Generate the hash/compare functions we add to user-defined types by default.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ConstraintSolver.TcValF">
<summary>
 function type that denotes captured tcVal used in constraint solver
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ConstraintSolver">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.IterationIsAtTopLevel">
<summary>
 top of expr toplevel? (true) 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.TopLevelBindings">
<summary>
 val not defined under lambdas 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.RecursiveBindings">
<summary>
 v -&gt; recursive? * v list   -- the others in the mutual binding 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.DecisionTreeBindings">
<summary>
 bound in a decision tree? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.Defns">
<summary>
 v -&gt; binding repr 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.Uses">
<summary>
 v -&gt; context / APP inst args 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results">
<summary>
 Results is &quot;expr information&quot;.
 This could extend to be a full graph view of the expr.
 Later could support &quot;safe&quot; change operations, and optimisations could be in terms of those.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis">

</member>
<member name="T:Microsoft.FSharp.Compiler.Detuple">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Env.TcGlobals.memoize_file">
<summary>
 Memoization table to help minimize the number of ILSourceDocument objects we create
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Env.FSharpLib">

</member>
<member name="T:Microsoft.FSharp.Compiler.Env">

</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssemblyStaticLinkingMap.ILTypeMap">
<summary>
 The table of remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssemblyStaticLinkingMap.CreateNew">
<summary>
 Create a new static linking map, ready to populate with data.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssemblyStaticLinkingMap">
<summary>
 The mapping information for one [&lt;Generate&gt;] definition, used to guide static linking.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProviderGeneratedType">
<summary>
 One node in a tree. There is one overall tree for each [&lt;Generate&gt;] definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedExpr.UnderlyingExpressionString">
<summary>
 Convert the expression to a string for diagnostics
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeContext.RemapTyconRefs(Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object})">
<summary>
 Map the TyconRef objects, if any
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeContext">
<summary>
 The context used to interpret information in the closure of System.Type, System.MethodInfo and other 
 info objects coming from the type provider.

 At the moment this is the &quot;Type --&gt; ILTypeRef&quot; and &quot;Type --&gt; Tycon&quot; remapping 
 context for generated types (it is empty for erased types). This is computed from
 while processing the [&lt;Generate&gt;] declaration related to the type.

 Immutable (after type generation for a [&lt;Generate&gt;] declaration populates the dictionaries).

 The &apos;obj&apos; values are all TyconRef, but obj is used due to a forward reference being required. Not particularly
 pleasant, but better than intertwining the whole &quot;ProvidedType&quot; with the TAST structure.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.temporaryFolder">
<summary>
 The folder for temporary files
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.referencedAssemblies">
<summary>
 All referenced assemblies, including the type provider itself, and possibly other type providers.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.showResolutionMessages">
<summary>
 Whether or not the --showextensionresolution flag was supplied to the compiler.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.outputFile">
<summary>
 Output file name
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.resolutionFolder">
<summary>
 The folder from which an extension provider is resolving from. This is typically the project folder.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment">
<summary>
 Carries information about the current extension type resolution environment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetOriginalILTypeRefOfProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get location of a type before it is relocated by static linking
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetILTypeRefOfProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the parts of the name that encloses the .NET type including nested types, using the scheme needed for ILTypeRef 
 e.g. System.Object -&gt; [&quot;System.Object&quot;]
 e.g. Something.ClassType.NestedType -&gt; [&quot;Something.ClassType&quot;; &quot;NestedType&quot;]
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetFSharpPathToProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Decompose the enclosing name of a type (including any class nestings) into a list of parts.
 e.g. System.Object -&gt; [&quot;System&quot;; &quot;Object&quot;]
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetPartsOfDotNetNamespace(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},System.String)">
<summary>
 Decompose a .NET namespace into a list of parts.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.TryLinkProvidedType(Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},System.String[],System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Try to resolve a type in the given extension type resolver
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.TryResolveProvidedType(Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},Microsoft.FSharp.Compiler.Range.range,System.String[],System.String)">
<summary>
 Try to resolve a type in the given extension type resolver
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.TryApplyProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},System.Object[],Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Try to apply a provided type to the given static arguments. If successful also return a function 
 to check the type name is as expected (this function is called by the caller of TryApplyProvidedType
 after other checks are made).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ValidateProvidedTypeAfterStaticInstantiation(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},System.String[],System.String)">
<summary>
 Validate that the given provided type meets some of the rules for F# provided types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.DisplayNameOfTypeProvider(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Given an extension type resolver, supply a human-readable name suitable for error messages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetTypeProvidersOfAssembly(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Boolean,Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus}},System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,System.String,Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},System.Version,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Return the set of extension type resolvers for the given assembly.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeResolutionNoRange">
<summary>
 Raised when an type provider has thrown an exception.    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeResolution">
<summary>
 Raised when a type provider has thrown an exception.    
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus.Trusted">
<summary>
 Trusted(absoluteFileName)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus.NotTrusted">
<summary>
 NotTrusted(absoluteFileName)
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.replaceApprovalStatus(Microsoft.FSharp.Core.FSharpOption{System.IO.FileStream},Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus)">
<summary>
 replace one piece of TP approval info (or append it, if this is a new filename).  may throw if trouble with file IO.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.readApprovalsFile(Microsoft.FSharp.Core.FSharpOption{System.IO.FileStream})">
<summary>
 read all TP approval data.  does not throw, will swallow exceptions and return empty list if there&apos;s trouble.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.doWithApprovalsFile``1(Microsoft.FSharp.Core.FSharpOption{System.IO.FileStream},Microsoft.FSharp.Core.FSharpFunc{System.IO.FileStream,``0})">
<summary>
 do a transaction of operations over approvals file under exclusive lock.  may throw if trouble with file IO.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.ApprovalsAbsoluteFileName">
<summary>
 location of approvals data file, e.g. C:\Users\username\AppData\Local\Microsoft\VisualStudio\11.0\type-providers.txt
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.GlobalsTheLanguageServiceCanPoke">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.FindUnsolved">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Formats">
<summary>
 Parse &quot;printf-style&quot; format specifiers at compile time, producing
 a list of items that specify the types of the things that follow.

 Must be updated if the Printf runtime component is updated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.LookupGeneratedValue(Microsoft.FSharp.Compiler.Ilxgen.ExecutionContext,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Invert the compilation of the given value and return its current dynamic value and its compiled System.Type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.GenerateCode(Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions,Microsoft.FSharp.Compiler.Tast.TypedAssembly,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Generate ILX code for an assembly fragment
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.CreatePermissionSets(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Create the CAS permission sets for an assembly fragment
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.ClearGeneratedValue(Microsoft.FSharp.Compiler.Ilxgen.ExecutionContext,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Invert the compilation of the given value and clear the storage of the value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.AddIncrementalLocalAssemblyFragment(System.Boolean,System.String,Microsoft.FSharp.Compiler.Tast.TypedAssembly)">
<summary>
 Register a fragment of the current assembly with the ILX code generator. If &apos;isIncrementalFragment&apos; is true then the input
 is assumed to be a fragment &apos;typed&apos; into FSI.EXE, otherwise the input is assumed to be the result of a &apos;#load&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.AddExternalCcus(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.CcuThunk})">
<summary>
 Register a set of referenced assemblies with the ILX code generator
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.#ctor(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType}}}}},Microsoft.FSharp.Compiler.Tast.CcuThunk)">
<summary>
 Create an incremental ILX code generator for a single assembly
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator">
<summary>
 An incremental ILX code generator for a single assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.ExecutionContext">
<summary>
 Used to support the compilation-inversion operations &quot;ClearGeneratedValue&quot; and &quot;LookupGeneratedValue&quot;
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.quotationResourceBytes">
<summary>
 The generated IL/ILX resources associated with F# quotations
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.ilNetModuleAttrs">
<summary>
 The generated IL/ILX .NET module attributes
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.ilAssemAttrs">
<summary>
 The generated IL/ILX assembly attributes
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.ilTypeDefs">
<summary>
 The generated IL/ILX type definitions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults">
<summary>
 The results of the ILX compilation of one fragment of an assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions.alwaysCallVirt">
<summary>
 Indicates that, whenever possible, use callvirt instead of call
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions.isInteractive">
<summary>
 Indicates the code is being generated in FSI.EXE and is executed immediately after code generation
 This includes all interactively compiled code, including #load, definitions, and expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions.mainMethodInfo">
<summary>
 If this is set, then the last module becomes the &quot;main&quot; module 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.IlxGenBackend">
<summary>
 Indicates how the generated IL code is ultimately emitted 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Import.ImportMap">
<summary>
 This is the context used for converting AbstractIL .NET and provided types to F# (*internal*) compiler data structures.
 We currently cache the conversion of AbstractIL ILTypeRef nodes, based on hashes of these.

 There is normally only one ImportMap for any assembly compilation, though additional instances can be created
 using tcImports.GetImportMap() if needed, and it is not harmful if multiple instances are used. The object 
 serves as an interface through to the tables stored in the primary TcImports structures defined in build.fs. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Import.AssemblyLoader.RecordGeneratedTypeRoot(Microsoft.FSharp.Compiler.ExtensionTyping.ProviderGeneratedType)">
<summary>
 Record a root for a [&lt;Generate&gt;] type to help guide static linking &amp; type relocation
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Import.AssemblyLoader.GetProvidedAssemblyInfo(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssembly})">
<summary>
 Get a flag indicating if an assembly is a provided assembly, plus the
 table of information recording remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Import">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.SigOfFunctionForDelegate">
<summary>
 The Invoke MethInfo, the function argument types, the function return type 
 and the overall F# function type for the function type associated with a .NET delegate type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.IndexedList`1">
<summary>
 The input list is sorted from most-derived to least-derived type, so any System.Object methods 
 are at the end of the list. Return a filtered list where prior/subsequent members matching by name and 
 that are in the same equivalence class have been removed. We keep a name-indexed table to 
 be more efficient when we check to see if we&apos;ve already seen a particular named method. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.FindMemberFlag.PreferOverrides">
<summary>
 Get overrides instead of abstract slots when measuring whether a class/interface implements all its required slots. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.FindMemberFlag.IgnoreOverrides">
<summary>
 Prefer items toward the top of the hierarchy, which we do if the items are virtual 
 but not when resolving base calls. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.InfoReader.GetRawIntrinsicMethodSetsOfType(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Read the method infos for a type

 Cache the result for monomorphic types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.InfoReader">
<summary>
 An InfoReader is an object to help us read and cache infos. 
 We create one of these for each file we typecheck. 

 REVIEW: We could consider sharing one InfoReader across an entire compilation 
 run or have one global one for each (g,amap) pair.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.HierarchyItem">
<summary>
 Sets of methods up the hierarchy, ignoring duplicates by name and sig.
 Used to collect sets of virtual methods, protected methods, protected
 properties etc. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropertyCollector">
<summary>
 A helper type to help collect properties.

 Join up getters and setters which are not associated in the F# data structure 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain.AccessibleFromSomewhere">
<summary>
 Can access everything
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain.AccessibleFromSomeFSharpCode">
<summary>
 An AccessorDomain which returns everything but .NET private/internal items
 This is used 
    - when solving member trait constraints, which are solved independently of accessibility 
    - for failure paths in error reporting, e.g. to produce an error that an F# item is not accessible
    - an adhoc use in service.fs to look up a delegate signature
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain.AccessibleFrom">
<summary>
 AccessibleFrom(cpaths, tyconRefOpt)

 cpaths: indicates we have the keys to access any members private to the given paths 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain">
<summary>
 Represents the &apos;keys&apos; a particular piece of code can use to access other constructs?.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.CompiledSig">
<summary>
 Represents the information about the compiled form of a method signature. Used when analyzing implementation
 relations between members and abstract slots.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo.ProvidedEvent">
<summary>
 An F# use of an event backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo.ILEvent">
<summary>
 An F# use of an event backed by .NET metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo.FSEvent">
<summary>
 An F# use of an event backed by F#-declared metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo">
<summary>
 Describes an F# use of an event
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.TypeRef">
<summary>
 Get the declaring type of the event as an ILTypeRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.RemoveMethod">
<summary>
 Get the ILMethInfo describing the &apos;remove&apos; method associated with the event
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.RawMetadata">
<summary>
 Get the raw Abstract IL metadata for the event
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.Name">
<summary>
 Get the name of the event
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.IsStatic">
<summary>
 Indicates if the property is static
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.ILTypeInfo">
<summary>
 Get the declaring IL type of the event as an ILTypeInfo
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.AddMethod">
<summary>
 Get the ILMethInfo describing the &apos;add&apos; method associated with the event
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILEventInfo">
<summary>
 Describes an F# use of an event backed by Abstract IL metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo.ProvidedProp">
<summary>
 An F# use of a property backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo.ILProp">
<summary>
 An F# use of a property backed by Abstract IL metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo.FSProp">
<summary>
 An F# use of a property backed by F#-declared metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsVirtualProperty">
<summary>
 True if the getter (or, if absent, the setter) is a virtual method
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsDispatchSlot">
<summary>
 True if the getter (or, if absent, the setter) for the property is a dispatch slot
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo">
<summary>
 Describes an F# use of a property 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.SetterMethod">
<summary>
 Gets the ILMethInfo of the &apos;set&apos; method for the property
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.RawMetadata">
<summary>
 Get the raw Abstract IL metadata for the property
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.PropertyName">
<summary>
 Get the name of the property
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.IsStatic">
<summary>
 Indicates if the property is static
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.ILTypeInfo">
<summary>
 Get the declaring IL type of the property, including any generic instantiation
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.HasSetter">
<summary>
 Indicates if the property has a &apos;set&apos; method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.HasGetter">
<summary>
 Indicates if the property has a &apos;get&apos; method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.GetterMethod">
<summary>
 Gets the ILMethInfo of the &apos;get&apos; method for the property
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILPropInfo">
<summary>
 Describes an F# use of a property backed by Abstract IL metadata
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.UnionCaseRef">
<summary>
 Get a reference to the F# metadata for the uninstantiated union case
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.UnionCase">
<summary>
 Get the F# metadata for the uninstantiated union case
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.TypeInst">
<summary>
 Get the generic instantiation of the declaring type of the union case
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.TyconRef">
<summary>
 Get a reference to the F# metadata for the declaring union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.Tycon">
<summary>
 Get the F# metadata for the declaring union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.Name">
<summary>
 Get the name of the union case
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo">
<summary>
 Describes an F# use of a union case
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.TypeInst">
<summary>
 Get the generic instantiation of the declaring type of the field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.TyconRef">
<summary>
 Get a reference to the F# metadata for the F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.Tycon">
<summary>
 Get the F# metadata for the F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.RecdFieldRef">
<summary>
 Get a reference to the F# metadata for the uninstantiated field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.RecdField">
<summary>
 Get the F# metadata for the uninstantiated field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.Name">
<summary>
 Get the name of the field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.LiteralValue">
<summary>
 Indicate if the field is a literal field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.IsStatic">
<summary>
 Indicate if the field is a static field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.FieldType">
<summary>
 Get the (instantiated) type of the field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.EnclosingType">
<summary>
 Get the enclosing (declaring) type of the field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo">
<summary>
 Describes an F# use of a field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ProvidedField">
<summary>
 Represents a single use of a field backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILFieldInfo">
<summary>
 Represents a single use of a field backed by Abstract IL metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.TypeInst">
<summary>
 Get the type instantiation of the declaring type of the field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ScopeRef">
<summary>
 Get the scope used to interpret IL metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.LiteralValue">
<summary>
 Indicates if the field is a literal field with an associated literal value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsValueType">
<summary>
 Indicates if the field is a member of a struct or enum type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsStatic">
<summary>
 Indicates if the field is static
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsSpecialName">
<summary>
 Indicates if the field has the &apos;specialname&apos; property in the .NET IL
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsInitOnly">
<summary>
 Indicates if the field is readonly (in the .NET/C# sense of readonly)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILTypeRef">
<summary>
 Get a reference to the declaring type of the field as an ILTypeRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILFieldType">
<summary>
 Get the type of the field as an IL type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILFieldRef">
<summary>
 Get an (uninstantiated) reference to the field as an Abstract IL ILFieldRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.FieldName">
<summary>
 GENERIC TYPE PROVIDERS
 Get the name of the field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.EnclosingType">
<summary>
 Get the enclosing (&quot;parent&quot;/&quot;declaring&quot;) type of the field. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.FieldType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the type of the field as an F# type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILFieldInfo">
<summary>
 Represents a single use of a IL or provided field from one point in an F# program
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.ProvidedMeth">
<summary>
 Describes a use of a method backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.DefaultStructCtor">
<summary>
 Describes a use of a pseudo-method corresponding to the default constructor for a .NET struct type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.ILMeth">
<summary>
 ILMeth(tcGlobals, ilMethInfo, extensionMethodPriority).

 Describes a use of a method backed by Abstract IL # metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.FSMeth">
<summary>
 FSMeth(tcGlobals, declaringType, valRef, extensionMethodPriority).

 Describes a use of a method declared in F# code and backed by F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.XmlDoc">
<summary>
 Get the XML documentation associated with the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.TcGlobals">
<summary>
 Get the TcGlobals value that governs the method declaration
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.Priority">
<summary>
 Get the extension method priority of the method, if it has one.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.LogicalName">
<summary>
 Get the method name in LogicalName form, i.e. the name as it would be stored in .NET metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsInstance">
<summary>
 Does the method appear to the user as an instance method?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.HasDirectXmlComment">
<summary>
 Indicates if this is a method defined in this assembly with an (*internal*) XML comment
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.FormalMethodTypars">
<summary>
 Get the formal generic method parameters for the method as a list of type variables.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.FormalMethodInst">
<summary>
 Get the formal generic method parameters for the method as a list of variable types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.EnclosingType">
<summary>
 Get the enclosing (&quot;parent&quot;/&quot;declaring&quot;) type of the method info. If this is an extension member,
 then this is the apparent parent.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.DisplayName">
<summary>
 Get the method name in DisplayName form
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.DebuggerDisplayName">
<summary>
 Get the method name in DebuggerDisplayForm
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.ArbitraryValRef">
<summary>
 Try to get an F# ValRef for the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.ActualTypeInst">
<summary>
 Get the actual type instantiation of the declaring type associated with this use of the method.
 If this is an extension member, then this is the actual instantiation of the apparent parent 
 of the member.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetSlotSig(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the signature of an abstract method slot.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetParamTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the parameter types of a method info
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetParamDatas(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the ParamData objects for the parameters of a MethInfo
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetParamAttribs(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the parameter attributes of a method info, which get combined with the parameter names and types
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetObjArgTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the (zero or one) &apos;self&apos;/&apos;this&apos;/&apos;object&apos; arguments associated with a method. An instance extension method returns
 one object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetFormalTyparsOfEnclosingType(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Select all the type parameters of the declaring type of a method. 

 For extension methods, no type parameters are returned,
 because all the type parameters are considered to be associated with the method, rather than the declaring type, even for extension
 methods extending generic types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetFSharpReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the return type of a method info, where &apos;void&apos; is returned as &apos;unit&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetCompiledReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the return type of a method info, where &apos;void&apos; is returned as &apos;None&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo">
<summary>
 Describes an F# use of a method
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ExtensionMethodPriority">
<summary>
 Describes the sequence order of the introduction of an extension method. Extension methods that are introduced
 later through &apos;open&apos; get priority in overload resolution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILFSMethInfo">
<summary>
 ILFSMethInfo(DeclaringType, FSharpObjKind, extensionMethodInfo, ilMethodDef)
 - DeclaringType refers apparent parent type
 - FSharpObjKind Indicates whether the type declaration is a class, interface, enum, delegate or struct   
 Describes an F# use of an IL extension method on F# object.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILMethInfo">
<summary>
 ILMethInfo(ilDeclaringTypeInfo, extensionMethodInfo, ilMethodDef, ilGenericMethodTyArgs)

 Describes an F# use of an IL method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.RawMetadata">
<summary>
 Get the Abstract IL metadata associated with the method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ParamMetadata">
<summary>
 Get the Abstract IL metadata corresponding to the parameters of the method. If this is a C# extension
 method then drop the object argument.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.NumParams">
<summary>
 Get the number of parameters of the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.MetadataScope">
<summary>
 Get the Abstract IL scope information associated with interpreting the Abstract IL metadata that backs this method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsVirtual">
<summary>
 Indicates if the IL method is marked virtual.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsStatic">
<summary>
 Does it appear to the user as a static method?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsProtectedAccessibility">
<summary>
 Indicates if the method has protected accessibility,
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsNewSlot">
<summary>
 Does it have the .NET IL &apos;newslot&apos; flag set, and is also a virtual?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsInstance">
<summary>
 Does it appear to the user as an instance method?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsFinal">
<summary>
 Indicates if the IL method is marked final.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsConstructor">
<summary>
 Indicates if the method is a constructor
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsClassConstructor">
<summary>
 Indicates if the method is a class initializer.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsCSharpExtensionMethod">
<summary>
 Indicates if the method is an extension method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsAbstract">
<summary>
 Indicates if the IL method is marked abstract.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILTypeRef">
<summary>
 Get a reference to the named declaring type associated with the method, as an ILTypeRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILTypeInfo">
<summary>
 Get the declaring type of the method as an ILTypeInfo. If this is an extension method, this is apparent type, i.e. the 
 logical type being extended. If this is an extension method on a F# type, nothing returns.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILName">
<summary>
 Get the IL name of the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILMethodRef">
<summary>
 Get a reference to the method (dropping all generic instantiations), as an Abstract IL ILMethodRef.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GenericArity">
<summary>
 Get the number of generic parameters of the method. This includes all type parameters even if this is a C# extension method extending a generic type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ExtensionMethodInfo">
<summary>
 Get the actual IL parent of a C#-style extension member with IL backing metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.EnclosingType">
<summary>
 Get the declaring type of the method as an F# type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ActualTypeInst">
<summary>
 Get the instantiation of the declaring type of the method. If this is a C# extension method then this is empty.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ActualILTypeRef">
<summary>
 Get the declaring type of the method. If this is a C# extension method then this is the C# type
 holding the static member that is the extension method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsDllImport(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if the method is marked as a DllImport (a PInvoke). This is done by looking at the IL custom attributes on 
 the method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetRawArgTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get all the argument types of the IL method. Include the object argument even if this is a C# extension method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetParamTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the argument types of the the IL method. If this is a C# extension method then drop the object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetParamNamesAndTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get info about the arguments of the IL method. If this is a C# extension method then drop the object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetObjArgTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the (zero or one) &apos;self&apos;/&apos;this&apos;/&apos;object&apos; arguments associated with an IL method. An instance extension method returns
 one object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetFSharpReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the F# view of the return type of an ILMethInfo, where &apos;void&apos; is &apos;unit&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetCompiledReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the compiled return type of an ILMethInfo, where &apos;void&apos; is None.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.Create(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.ILTypeInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef},Microsoft.FSharp.Core.FSharpOption{System.UInt64},Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Build IL method infos.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILMethInfo">
<summary>
 Describes an F# use of an IL method.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.CallerSide">
<summary>
 The argument is optional, and is a caller-side .NET optional or default arg 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.CalleeSide">
<summary>
 The argument is optional, and is an F# callee-side optional arg 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.NotOptional">
<summary>
 The argument is not optional
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgCallerSideValue">
<summary>
 The caller-side value for the optional arg, is any 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILTypeInfo.ILTypeInfo">
<summary>
 ILTypeInfo (tyconRef, ilTypeRef, typeArgs, ilTypeDef).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILTypeInfo">
<summary>
 Describes an F# use of an IL type, including the type instantiation associated with the type at a particular usage point.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations">
<summary>
 Indicates whether we should visit multiple instantiations of the same generic interface or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropTypOfEventInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Get the type of the event when looked at as if it is a property 
 Used when displaying the property in Intellisense 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ArgsTypOfEventInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Get the (perhaps tupled) argument type accepted by an event 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.IsStandardEventInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Indicates if an event info is associated with a delegate type that is a &quot;standard&quot; .NET delegate type
 with a sender parameter.
 In the F# design, we take advantage of the following idiom to simplify away the bogus &quot;object&quot; parameter of the 
 of the &quot;Add&quot; methods associated with events.  If you want to access it you
 can use AddHandler instead.
 The .NET Framework guidelines indicate that the delegate type used for
 an event should take two parameters, an &quot;object source&quot; parameter
 indicating the source of the event, and an &quot;e&quot; parameter that
 encapsulates any additional information about the event. The type of
 the &quot;e&quot; parameter should derive from the EventArgs class. For events
 that do not use any additional information, the .NET Framework has
 already defined an appropriate delegate type: EventHandler.
 (from http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vcwlkEventsTutorial.asp) 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryDestStandardDelegateTyp(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try and interpret a delegate type as a &quot;standard&quot; .NET delegate type associated with an event, with a &quot;sender&quot; parameter.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetSigOfFunctionForDelegate(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain)">
<summary>
 Given a delegate type work out the minfo, argument types, return type 
 and F# function type by looking at the Invoke signature of the delegate. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryFindPropInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,System.String,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try to find a particular named property on a type. Only used to ensure that local &apos;let&apos; definitions and property names
 are distinct, a somewhat adhoc check in tc.fs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryFindIntrinsicMethInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,System.String,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try to detect the existence of a method on a type.
 Used for 
     -- getting the GetEnumerator, get_Current, MoveNext methods for enumerable types 
     -- getting the Dispose method when resolving the &apos;use&apos; construct 
     -- getting the various methods used to desugar the computation expression syntax 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryFindIntrinsicNamedItemOfType(Microsoft.FSharp.Compiler.Infos.InfoReader,System.String,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.FindMemberFlag,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Perform type-directed name resolution of a particular named member in an F# type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FilterOverridesOfMethInfos(Microsoft.FSharp.Compiler.Infos.FindMemberFlag,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Infos.MethInfo}})">
<summary>
      (a) not virtual
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.emptyIndexedList``1">
<summary>
 Add all the items to the IndexedList if better items are not already present. This is used to hide methods
 in super classes and/or hide overrides of methods in subclasses.

 Assume no items in &apos;items&apos; are equivalent according to &apos;equiv&apos;. This is valid because each step in a
 .NET class hierarchy introduces a consistent set of methods, none of which hide each other within the 
 given set. This is an important optimization because it means we don&apos;t have to List.filter for equivalence between the 
 large overload sets introduced by methods like System.WriteLine.
 Assume items can be given names by &apos;nmf&apos;, where two items with different names are
 not equivalent.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetIntrinsicConstructorInfosOfType(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the constructors of any F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ConstructorInfosOfILType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the constructors of an IL type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetImmediateIntrinsicPropInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Query the immediate properties of an F# type, not taking into account inherited properties. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetImmediateIntrinsicMethInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Query the immediate methods of an F# type, not taking into account inherited methods. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TrySelectMemberVal``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpOption{System.UInt64},``0,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Try to select an F# value when querying members, and if so return a MethInfo that wraps the F# value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.checkFilter(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Check whether a name matches an optional filter
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.SelectImmediateMemberVals``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValMemberInfo,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpOption{``0}}},Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Use the given function to select some of the member values from the members of an F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MakeMethInfoCall(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Make a call to a method info. Used by the optimizer and code generator to build 
 calls to the type-directed solutions to member constraints.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildFSharpMethodCall(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build a call to an F# method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildFSharpMethodApp(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build a call to an F# method.

 Consume the arguments in chunks and build applications.  This copes with various F# calling signatures
 all of which ultimately become &apos;methods&apos;.

 QUERY: this looks overly complex considering that we are doing a fundamentally simple 
 thing here. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildObjCtorCall(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Build a call to the System.Object constructor taking no arguments,
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildILMethInfoCall(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Infos.ILMethInfo,Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build an expression node that is a call to a .NET method. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfosEquivByNameAndSig(Microsoft.FSharp.Compiler.Tastops.Erasure,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.PropInfo,Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfosEquivByNameAndSig(Microsoft.FSharp.Compiler.Tastops.Erasure,System.Boolean,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfosEquivByNameAndPartialSig(Microsoft.FSharp.Compiler.Tastops.Erasure,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.PropInfo,Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfosEquivByNameAndPartialSig(Microsoft.FSharp.Compiler.Tastops.Erasure,System.Boolean,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.CompiledSigOfMeth(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Get the information about the compiled form of a method signature. Used when analyzing implementation
 relations between members and abstract slots.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.mkSlotSig(System.String,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.SlotParam}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Construct the data representing the signature of an abstract method slot
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.mkSlotParam(Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ArgReprInfo)">
<summary>
 Construct the data representing a parameter in the signature of an abstract method slot
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ReparentSlotSigToUseMethodTypars(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.SlotSig)">
<summary>
 The slotsig returned by methInfo.GetSlotSig is in terms of the type parameters on the parent type of the overriding method.
 Reverse-map the slotsig so it is in terms of the type parameters for the overriding method 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetCompiledReturnTyOfProvidedMethodInfo(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedMethodBase})">
<summary>
 Get the return type of a provided method, where &apos;void&apos; is returned as &apos;None&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.CombineMethInsts(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Combine the type instantiation and generic method instantiation
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.InstMethInfo(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TType}},Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Apply a type instantiation to a method info, i.e. apply the instantiation to the enclosing type. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetEventInfoHashCode(Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Calculates a hash code of event info (similar as previous)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetPropInfoHashCode(Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Calculates a hash code of property info (similar as previous)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetMethInfoHashCode(Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Calculates a hash code of method info. Note: this is a very imperfect implementation,
 but it works decently for comparing methods in the language service...
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.EventInfosUseIdenticalDefintions(Microsoft.FSharp.Compiler.Infos.EventInfo,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Test whether two event infos have the same underlying definition.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfosUseIdenticalDefinitions(Microsoft.FSharp.Compiler.Infos.PropInfo,Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Tests whether two property infos have the same underlying definition.
 Uses the same techniques as pervious &apos;MethInfosUseIdenticalDefinitions&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfosUseIdenticalDefinitions``1(``0,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Tests whether two method infos have the same underlying definition.
 Used to merge operator overloads collected from left and right of an operator constraint.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FindDelegateTypeOfPropertyEvent(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,System.String,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Find the delegate type that an F# event property implements by looking through the type hierarchy of the type of the property
 for the first instantiation of IDelegateEvent.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.nonStandardEventError(System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Create an error object to raise should an event not have the shape expected by the .NET idiom described further below 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.tyConformsToIDelegateEvent(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Properties compatible with type IDelegateEvent and atributed with CLIEvent are special: we generate metadata and add/remove methods 
 to make them into a .NET event, and mangle the name of a property.  
 We don&apos;t handle static, indexer or abstract properties correctly. 
 Note the name mangling doesn&apos;t affect the name of the get/set methods for the property 
 and so doesn&apos;t affect how we compile F# accesses to the property. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AnalyzeTypeOfMemberVal(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Split the type of an F# member value into 
    - the type parameters associated with method but matching those of the enclosing type
    - the type parameters associated with a generic method
    - the return type of the method
    - the actual type arguments of the enclosing type.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.OptionalArgInfoOfILParameter(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter)">
<summary>
 ParamData(isParamArray, isOut, optArgInfo, nameOpt, ttype)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ValRef.IsFSharpEventProperty(Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if an F#-declared function or member value is a CLIEvent property compiled as a .NET event
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MemberRefIsDispatchSlot(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Check if an F#-declared member value is a dispatch slot
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MemberRefIsDefiniteFSharpOverride(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Check if an F#-declared member value is an &apos;override&apos; or explicit member implementation
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MemberRefIsVirtual(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Check if an F#-declared member value is a virtual method
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FixupNewTypars(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar})">
<summary>
 The constraints for each typar copied from another typar can only be fixed up once 
 we have generated all the new constraints, e.g. f&lt;A :&gt; List&lt;B&gt;, B :&gt; List&lt;A&gt;&gt; ... 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.CopyTyparConstraints(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TType}},Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Copy constraints.  If the constraint comes from a type parameter associated
 with a type constructor then we are simply renaming type variables.  If it comes
 from a generic method in a generic class (e.g. typ.M&lt;_&gt;) then we may be both substituting the
 instantiation associated with &apos;typ&apos; as well as copying the type parameters associated with 
 M and instantiating their constraints

 Note: this now looks identical to constraint instantiation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ImportReturnTypeFromMetaData(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the return type of an IL method, taking into account instantiations for type and method generic parameters, and
 translating &apos;void&apos; to &apos;None&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ImportTypeFromMetadata(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Read an Abstract IL type from metadata and convert to an F# type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ExistsHeadTypeInEntireHierarchy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Check if a type exists somewhere in the hierarchy which has the given head type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ExistsSameHeadTypeInHierarchy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Check if a type exists somewhere in the hierarchy which has the same head type as the given type (note, the given type need not have a head type at all)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.HasHeadType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Check if a type has a particular head type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.HaveSameHeadType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Check if two types have the same nominal head type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AllInterfacesOfType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get all interfaces of a type, including the type itself if it is an interface
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AllSuperTypesOfType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get all super types of the type, including the type itself
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.SearchEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,System.Boolean},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Search for one element where a function returns a &apos;Some&apos; result, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ExistsInEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,System.Boolean},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Search for one element satisfying a predicate, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.IterateEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Iterate, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FoldEntireHierarchyOfType``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType,``0)">
<summary>
 Fold, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FoldPrimaryHierarchyOfType``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType,``0)">
<summary>
 Fold, do not follow interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FoldHierarchyOfTypeAux``1(System.Boolean,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,``0)">
<summary>
 Traverse the type hierarchy, e.g. f D (f C (f System.Object acc)). 
 Visit base types and interfaces first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetImmediateInterfacesOfType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Collect the set of interface types supported by an F# type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ImportType(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 importInst gives the context for interpreting type variables 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckProvidedAttributesForUnseen(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.IProvidedCustomAttributeProvider},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check provided attributes for existence of &apos;ObsoleteAttribute&apos;, to suppress the item in intellisense
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckFSharpAttributesForUnseen``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},``0)">
<summary>
 Check F# attributes for existence of &apos;ObsoleteAttribute&apos;, to suppress the item in intellisense
 Also check F# attributes for CompilerMessageAttribute, which has an IsHidden argument that allows
 items to be suppressed from intellisense.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckILAttributesForUnseen``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributes,``0)">
<summary>
 Check IL attributes for existence of &apos;ObsoleteAttribute&apos;, to suppress the item in intellisense
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckFSharpAttributes(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check F# attributes for &apos;ObsoleteAttribute&apos;, &apos;CompilerMessageAttribute&apos; and &apos;ExperimentalAttribute&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckILAttributes(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributes,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check IL attributes for &apos;ObsoleteAttribute&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.TryFindTyconRefStringAttribute(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Env.BuiltinAttribInfo,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 This is used to detect the &apos;DefaultMemberAttribute&apos; and &apos;ConditionalAttribute&apos; attributes (on type definitions)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.TryFindMethInfoStringAttribute(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Env.BuiltinAttribInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 This is just used for the &apos;ConditionalAttribute&apos; attribute
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AttributeChecking">
<summary>
 Check custom attributes. This is particularly messy because custom attributes come in in three different
 formats.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessibilityLogic">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos">
<summary>
 tinfos, minfos, finfos, pinfos - summaries of information for references
 to .NET and F# constructs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Layout">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.StartPos">
<summary>
 Returns starting position of the token
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.EndPos">
<summary>
 Returns end position of the token
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.UseShiftedLocation(Microsoft.FSharp.Compiler.Parser.token,System.Int32,System.Int32)">
<summary>
 Returns a token &apos;tok&apos; with the same position as this token, except that 
 it is shifted by specified number of characters from the left and from the right
 Note: positive value means shift to the right in both cases
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.UseLocation(Microsoft.FSharp.Compiler.Parser.token)">
<summary>
 Returns a token &apos;tok&apos; with the same position as this token
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexfilter.TokenTup">
<summary>
 Used to save the state related to a token
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexfilter.LexbufState">
<summary>
 Used to save some aspects of the lexbuffer state
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.isTryBlockContinuator(Microsoft.FSharp.Compiler.Parser.token)">
<summary>
 Determine the token that may align with the &apos;try&apos; of a &apos;try/catch&apos; or &apos;try/finally&apos; without closing
 the construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.isIfBlockContinuator(Microsoft.FSharp.Compiler.Parser.token)">
<summary>
 Determine the tokens that may align with the &apos;if&apos; of an &apos;if/then/elif/else&apos; without closing
 the construct
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.warningStringOfPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 Used for warning strings, which should display columns as 1-based and display 
 the lines after taking &apos;# line&apos; directives into account (i.e. do not use
 p.OriginalLine)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexfilter">
<summary>
 LexFilter - process the token stream prior to parsing.
 Implements the offside rule and a copule of other lexical transformations.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexhelp.Keywords">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexhelp">

</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.stateVars">
<summary>
 The state variables allocated for one portion of the sequence expression (i.e. the local let-bound variables which become state variables)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.significantClose">
<summary>
 any actual work done in Close
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.labels">
<summary>
 The labels allocated for one portion of the sequence expression
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.phase2">
<summary>
 The code to run in the second phase, to rebuild the expressions, once all code labels and their mapping to program counters have been determined
 &apos;nextVar&apos; is the argument variable for the GenerateNext method that represents the byref argument that holds the &quot;goto&quot; destination for a tailcalling sequence expression
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lowertop.LowerSeqExpr(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Analyze a TAST expression to detect the elaborated form of a sequence expression.
 Then compile it to a state machine represented as a TAST containing goto, return and label nodes. 
 The returned state machine will also contain references to state variables (from (*internal*) &apos;let&apos; bindings),
 a program counter (pc) that records the current state, and a current generated value (current).
 All these variables are then represented as fields in a hosting closure object along with any additional
 free variables of the sequence expression.

 The analysis is done in two phases. The first phase determines the state variables and state labels (as Abstract IL code labels).
 We then allocate an integer pc for each state label and proceed with the second phase, which builds two related state machine
 expressions: one for &apos;MoveNext&apos; and one for &apos;Dispose&apos;.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lowertop.LowerImplFile(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TypedImplFile)">
<summary>
 An &quot;expr -&gt; expr&quot; pass that eta-expands under-applied values of 
 known arity to lambda expressions and beta-var-reduces to bind 
 any known arguments.  The results are later optimized by the peephole 
 optimizer in opt.fs
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lowertop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.MSBuildResolver.DecodeResolvedFrom(System.String)">
<summary>
 Decode the ResolvedFrom code from MSBuild.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.MSBuildResolver.DeriveTargetFrameworkDirectories(System.String,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Derive the target framework directories.        
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.MSBuildResolver">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.PermitDirectReferenceToGeneratedType">
<summary>
 Indicates whether we permit a direct reference to a type generator. Only set when resolving the
 right-hand-side of a [&lt;Generate&gt;] declaration.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Nameres.TypeNameResolutionStaticArgsInfo.DefiniteEmpty">
<summary>
 Indicates definite knowledge of empty type arguments, i.e. the logical equivalent of name&lt; &gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Nameres.TypeNameResolutionStaticArgsInfo.FromTyArgs(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynType})">
<summary>
 Deduce definite knowledge of type arguments
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.Item.ArgName">
<summary>
 Represents the resolution of a source identifier to a named argument
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.Item.ImplicitOp">
<summary>
 Represents the resolution of a source identifier to an implicit use of an infix operator
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.Item.CustomOperation">
<summary>
 CustomOperation(operationName, operationHelpText, operationImplementation).
 
 Used to indicate the availability or resolution of a custom query operation such as &apos;sortBy&apos; or &apos;where&apos; in computation expression syntax
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.NameResolver">
<summary>
 A NameResolver primarily holds an InfoReader
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.minimalStringsOfTwoTypes(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Generate text for comparing two types.

 If the output text is different without showing constraints and/or imperative type variable 
 annotations and/or fully qualifying paths then don&apos;t show them! 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.stringOfParamData(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.ParamData)">
<summary>
 Convert a ParamData to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.stringOfMethInfo(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Convert a MethInfo to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.formatMethInfoToBufferFreeStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Convert a MethInfo to a string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.outputQualifiedValOrMember(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Print members with a qualification showing the type they are contained in 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintData.dataExprL(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Nice printing of a subset of expressions, e.g. for refutations in pattern matching
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintData">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InferredSigPrinting.layoutInferredSigOfModuleExpr(System.Boolean,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExprWithSig)">
<summary>
 Layout the inferred signature of a compilation unit
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.InferredSigPrinting">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.TastDefinitionPrinting.layoutProvidedTycon(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Core.FSharpOption{System.String},Internal.Utilities.StructuredFormat.Layout,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Another re-implementation of type printing, this time based off provided info objects.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.TastDefinitionPrinting.breakTypeDefnEqn(Microsoft.FSharp.Compiler.Tast.TyconRepresentation)">
<summary>
 When to force a break? &quot;type tyname = &lt;HERE&gt; repn&quot;
 When repn is class or datatype constructors (not single one).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.TastDefinitionPrinting">
<summary>
 Printing TAST objects
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.layoutMethInfoFSharpStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Format a method to a layotu (actually just containing a string) using &quot;free style&quot; (aka &quot;standalone&quot;). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatMethInfoToBufferFreeStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Format a method to a buffer using &quot;standalone&quot; display style. 
 For example, these are the formats used when printing signatures of methods that have not been overriden,
 and the format used when showing the individual member in QuickInfo and DeclarationInfo.
 The formats differ between .NET/provided methods and F# methods. Surprisingly people don&apos;t really seem 
 to notice this, or they find it helpful. It feels that moving from this position should not be done lightly.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatMethInfoToBufferCSharpStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Format a method info using &quot;half C# style&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatMethInfoToBufferFSharpStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Format a method info using &quot;F# style&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatParamDataToBuffer(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.ParamData)">
<summary>
 Format the arguments of a method to a buffer. 

 This uses somewhat &quot;old fashioned&quot; printf-style buffer printing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting">
<summary>
 Printing info objects
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintTastMemberOrVals">
<summary>
 Printing TAST objects
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTyparDecls(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Internal.Utilities.StructuredFormat.Layout,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar})">
<summary>
 Layout type parameters
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTopType(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ArgReprInfo}}},Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TyparConstraint}})">
<summary>
 Layout a single type used as the type of a member or value 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypeWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Layout a single type, taking TypeSimplificationInfo into account 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypesWithInfoAndPrec(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,System.Int32,Internal.Utilities.StructuredFormat.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Layout a list of types, separated with the given separator, either &apos;*&apos; or &apos;,&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypeWithInfoAndPrec(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,System.Int32,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Layout a type, taking precedence into account to insert brackets where needed *)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypeAppWithInfoAndPrec(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Internal.Utilities.StructuredFormat.Layout,System.Int32,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Layout type arguments, either NAME&lt;ty,...,ty&gt; or (ty,...,ty) NAME *)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutMeasure(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.MeasureExpr)">
<summary>
 Layout a unit expression 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutConstraintWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TyparConstraint)">
<summary>
 Layout constraints, taking TypeSimplificationInfo into account 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutConstraintsWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TyparConstraint}})">
<summary>
 Layout type parameter constraints, taking TypeSimplificationInfo into account 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTyparRefWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Layout a single type parameter declaration, taking TypeSimplificationInfo into account  
 There are several printing-cases for a typar:

  &apos;a              - is multiple  occurance.
  _               - singleton occurrence, an underscore prefered over &apos;b. (OCAML accepts but does not print)
  #Type           - inplace coercion constraint and singleton.
  (&apos;a :&gt; Type)    - inplace coercion constraint not singleton.
  (&apos;a.opM : S-&gt;T) - inplace operator constraint.

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttribs(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.TyparKind,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Layout &apos;[&lt;attribs&gt;]&apos; above another block 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttrib(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Attrib)">
<summary>
 Layout an attribute &apos;Type(arg1, ..., argN)&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttribArgs(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.AttribExpr})">
<summary>
 Layout arguments of an attribute &apos;arg1, ..., argN&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttribArg(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Layout a single attibute arg, following the cases of &apos;gen_attr_arg&apos; in ilxgen.fs
 This is the subset of expressions we display in the NicePrint pretty printer 
 See also dataExprL - there is overlap between these that should be removed 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutMemberFlags(Microsoft.FSharp.Compiler.Ast.MemberFlags)">
<summary>
 Layout the flags of a member 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTyconRef(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Layout a reference to a type 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintTypes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILMethodDef(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Layout a method&apos;s signature using type-only-F#-style. No argument names are printed.
 
 In the case that we&apos;ve a constructor, we
 pull off the class name from the `path`; naturally, it&apos;s the
 most-deeply-nested element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILParameters(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Layout a function pointer signature using type-only-F#-style. No argument names are printed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILParameter(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter)">
<summary>
 Layout a function pointer signature using type-only-F#-style. No argument names are printed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILCallingSignature(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.AbstractIL.IL.ILCallingSignature)">
<summary>
 Layout a function pointer signature using type-only-F#-style. No argument names are printed.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.adjustILMethodName(System.String)">
<summary>
 this fixes up a name just like adjustILName but also handles F#
 operators
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintIL">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintUtilities.adjustILName(System.String)">
<summary>
 fix up a name coming from IL metadata by quoting &quot;funny&quot; names (keywords, otherwise invalid identifiers)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintUtilities">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Opt.ModuleInfo">
<summary>
 Optimization information 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.RemapLazyModulInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tastops.Remap)">
<summary>
 Rewrite the modul info using the export remapping 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.p_LazyModuleInfo(System.Lazy{Microsoft.FSharp.Compiler.Opt.ModuleInfo},Microsoft.FSharp.Compiler.Pickle.WriterState)">
<summary>
 Saving and re-reading optimization information 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.moduleInfoL(Microsoft.FSharp.Compiler.Env.TcGlobals,System.Lazy{Microsoft.FSharp.Compiler.Opt.ModuleInfo})">
<summary>
 Displaying optimization data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.OptimizeImplFile(Microsoft.FSharp.Compiler.Opt.OptimizationSettings,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType}}}}},Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Opt.IncrementalOptimizationEnv,System.Boolean,System.Boolean,Microsoft.FSharp.Compiler.Tast.TypedImplFile)">
<summary>
 The entry point. Boolean indicates &apos;incremental extension&apos; in FSI 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.BindCcu(Microsoft.FSharp.Compiler.Tast.CcuThunk,System.Lazy{Microsoft.FSharp.Compiler.Opt.ModuleInfo},Microsoft.FSharp.Compiler.Opt.IncrementalOptimizationEnv,Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 For building optimization environments incrementally 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Opt">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Outcome">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Parser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Parser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Patcompile.Pattern">
<summary>
 Represents the typechecked, elaborated form of a pattern, prior to pattern-match compilation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Patcompile.ActionOnFailure">
<summary>
 What should the decision tree contain for any incomplete match? 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Patcompile.CompilePattern(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Patcompile.ActionOnFailure,Microsoft.FSharp.Compiler.Tast.Val,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Patcompile.TypedMatchClause},Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Compile a pattern into a decision tree and a set of targets.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Patcompile">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Pickle.PickledDataWithReferences`1.FixupThunks">
<summary>
 The assumptions that need to be fixed up
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Pickle.PickledDataWithReferences`1.RawData">
<summary>
 The data that uses a collection of CcuThunks internally
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Pickle.PickledDataWithReferences`1.OptionalFixup(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.CcuThunk}})">
<summary>
 Like Fixup but loader may return None, in which case there is no fixup.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Pickle">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.PostTypecheckSemanticChecks">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.QuotationPickler">
<summary>
 Code to pickle out quotations in the quotation binary format.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.QuotationTranslator">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.GetHashCodeTainted``1(Microsoft.FSharp.Compiler.Tainted{``0})">
<summary>
 Compute the hash value for the tainted value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.EqTainted``1(Microsoft.FSharp.Compiler.Tainted{``0},Microsoft.FSharp.Compiler.Tainted{``0})">
<summary>
 Test whether the tainted value equals given value. Type providers are ignored (equal tainted values produced by different type providers are equal)
 Failure in call to equality operation will be blamed on type provider of first operand
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.Eq``1(Microsoft.FSharp.Compiler.Tainted{``0},``0)">
<summary>
 Test whether the tainted value equals given value. 
 Failure in call to equality operation will be blamed on type provider of first operand
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.|Null|_|``1(Microsoft.FSharp.Compiler.Tainted{``0})">
<summary>
 Test whether the tainted value is null
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tainted">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompiledTypeRepr.ILAsmOpen">
<summary>
 An AbstractIL type representation that may include type variables
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompiledTypeRepr.ILAsmNamed">
<summary>
 An AbstractIL type representation that is just the name of a type.

 CompiledTypeRepr.ILAsmNamed (ilTypeRef, ilBoxity, ilTypeOpt)
 
 The ilTypeOpt is present for non-generic types. It is an ILType corresponding to the first two elements of the case. This
 prevents reallocation of the ILType each time we need to generate it. For generic types, it is None.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompiledTypeRepr">
<summary>
 Specifies the compiled representations of type and exception definitions.  Basically
 just an ILTypeRef. Computed and cached by later phases.  Stored in 
 type and exception definitions. Not pickled. Store an optional ILType object for 
 non-generic types.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeTyvars">
<summary>
 See FreeTyvars above.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeUnionCases">
<summary>
 The summary of union constructors used in the expression. These may be
 marked &apos;internal&apos; or &apos;private&apos; and we have to check various conditions associated with that.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeRecdFields">
<summary>
 The summary of fields used in the expression. These may be made private by a signature 
 or marked &apos;internal&apos; or &apos;private&apos; and we have to check various conditions associated with that. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeLocalTyconReprs">
<summary>
 The summary of locally defined tycon representations used in the expression. These may be made private by a signature 
 or marked &apos;internal&apos; or &apos;private&apos; and we have to check various conditions associated with that. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.UsesUnboundRethrow">
<summary>
 Indicates if the expression contains a call to rethrow that is not bound under a (try-)with branch. 
 Rethrow may only occur in such locations. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.UsesMethodLocalConstructs">
<summary>
 Indicates if the expression contains a call to a protected member or a base call. 
 Calls to protected members and direct calls to super classes can&apos;t escape, also code can&apos;t be inlined 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeLocals">
<summary>
 The summary of locally defined variables used in the expression. These may be hidden at let bindings etc. 
 or made private by a signature or marked &apos;internal&apos; or &apos;private&apos;, and we have to check various conditions associated with that. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeVars">
<summary>
 Represents the set of free variables in an an expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeVarsCache">
<summary>
 Represents an amortized computation of the free variables in an expression
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeTyvars.FreeTypars">
<summary>
 The summary of type parameters used in the expression. These may not escape the enclosing generic construct 
 and we have to check various conditions associated with that. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeTyvars.FreeTraitSolutions">
<summary>
 The summary of values used as trait solutions
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeTyvars.FreeTycons">
<summary>
 The summary of locally defined type definitions used in the expression. These may be made private by a signature 
 and we have to check various conditions associated with that. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeTyvars">
<summary>
 Represents a set of &apos;free&apos; type-related elements, including named types, trait solutions, union cases and
 record fields.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeUnionCases">
<summary>
 Represents a set of &apos;free&apos; union cases. Used to collect the union cases referred to from an expression.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeRecdFields">
<summary>
 Represents a set of &apos;free&apos; record field definitions. Used to collect the record field definitions referred to 
 from an expression.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeTycons">
<summary>
 Represents a set of &apos;free&apos; named type definitions. Used to collect the named type definitions referred to 
 from atype or expression.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeTypars">
<summary>
 Represents a set of free type parameters
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeLocals">
<summary>
 Represents a set of free local values.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TypedAssembly">
<summary>
 Represents a complete typechecked assembly, made up of multiple implementation files.

</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TypedImplFile">
<summary>
 This ModuleOrNamespace that represents the compilation of a module as a class. 
 The same set of tycons etc. are bound in the ModuleOrNamespace as in the ModuleOrNamespaceExpr
 This is the body of the module/namespace 
 Represents a complete typechecked implementation file, including its typechecked signature if any.

 TImplFile(qualifiedNameOfFile,pragmas,implementationExpressionWithSignature,hasExplicitEntryPoint,isScript)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceBinding">
<summary>
 A named module-or-namespace-fragment definition 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefRec">
<summary>
 Indicates the module fragment is a &apos;rec&apos; definition of types, values and modules
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefDo">
<summary>
 Indicates the module fragment is an evaluation of expression for side-effects
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefLet">
<summary>
 Indicates the module fragment is a &apos;let&apos; definition 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefs">
<summary>
 Indicates the module fragment is made of several module fragments in succession 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMAbstract">
<summary>
 Indicates the module is a module with a signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr">
<summary>
 The contents of a module-or-namespace-fragment definition 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExprWithSig.Type">
<summary>
 The ModuleOrNamespaceType is a binder. However it is not used in the ModuleOrNamespaceExpr: it is only referenced from the &apos;outside&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExprWithSig">
<summary>
 A type for a module-or-namespace-fragment and the actual definition of the module-or-namespace-fragment
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SlotParam">
<summary>
 Represents a parameter to an abstract method slot. 

 TSlotParam(nm,ty,inFlag,outFlag,optionalFlag,attribs)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SlotSig">
<summary>
 Represents an abstract method slot, or delegate signature.

 TSlotSig(methodName,declaringType,declaringTypeParameters,methodTypeParameters,slotParameters,returnTy)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ObjExprMethod">
<summary>
 A representation of a method in an object expression. 

 TObjExprMethod(slotsig,attribs,methTyparsOfOverridingMethod,methodParams,methodBodyExpr,m)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.StaticOptimization">
<summary>
 Indicates the kind of an F# core library static optimization construct
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.VSlotDirectCall">
<summary>
 A call to a base method, e.g. &apos;base.OnPaint(args)&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.CtorValUsedAsSelfInit">
<summary>
 A call to a constructor, e.g. &apos;new C() = new C(3)&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.CtorValUsedAsSuperInit">
<summary>
 A call to a constructor, e.g. &apos;inherit C()&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.NormalValUse">
<summary>
 A normal use of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.PossibleConstrainedCall">
<summary>
 Indicates a use of a value represents a call to a method that may require
 a .NET 2.0 constrained call. A constrained call is only used for calls where 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag">
<summary>
 Indicates how a value, function or member is being used at a particular usage point.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SequentialOpKind.ThenDoSeq">
<summary>
 let res = a in b;res 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SequentialOpKind.NormalSeq">
<summary>
 a ; b 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SequentialOpKind">
<summary>
 Indicates the kind of sequential operation, i.e. &quot;normal&quot; or &quot;to a before returning b&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LByrefSet">
<summary>
 In C syntax this is: *localv_ptr = e   
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LSet">
<summary>
 In C syntax this is:  localv = e     , note == *(&amp;localv) = e == LGetAddr; LByrefSet
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LByrefGet">
<summary>
 In C syntax this is: *localv_ptr        
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LGetAddr">
<summary>
 In C syntax this is: &amp;localv            
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation">
<summary>
 Indicates what kind of pointer operation this is.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle.CSharpForLoopUp">
<summary>
 Evaluate start once and end multiple times, loop up
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle.FSharpForLoopDown">
<summary>
 Evaluate start and end once, loop down
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle.FSharpForLoopUp">
<summary>
 Evaluate start and end once, loop up
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle">
<summary>
 Indicates the kind of looping operation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SpecialWhileLoopMarker">
<summary>
 Indicates the kind of looping operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ConstrainedCallInfo">
<summary>
 If this is Some(ty) then it indicates that a .NET 2.0 constrained call is required, witht he given type as the
 static type of the object argument.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecordConstructionInfo.RecdExpr">
<summary>
 Normal record construction 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecordConstructionInfo.RecdExprIsObjInit">
<summary>
 We&apos;re in an explicit constructor. The purpose of the record expression is to 
 fill in the fields of a pre-created but uninitialized object 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecordConstructionInfo">
<summary>
 Indicates the kind of record construction operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ILCall">
<summary>
 ILCall(useCallvirt,isProtected,valu,newobj,valUseFlags,isProp,noTailCall,mref,actualTypeInst,actualMethInst, retTy)
  
 IL method calls.
     value -- is the object a value type? 
     isProp -- used for quotation reflection.
     noTailCall - DllImport? if so don&apos;t tailcall 
     actualTypeInst -- instantiation of the enclosing type
     actualMethInst -- instantiation of the method
     retTy -- the types of pushed values, if any 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.LValueOp">
<summary>
 Operation nodes represnting C-style operations on byrefs and mutable vals (l-values) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TraitCall">
<summary>
 Pseudo method calls. This is used for overloaded operations like op_Addition. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Label">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Goto">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Return">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Reraise">
<summary>
 Represents a &quot;rethrow&quot; operation. May not be rebound, or used outside of try-finally, expecting a unit argument 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Coerce">
<summary>
 Conversion node, compiled via type-directed translation or to box/unbox 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.RefAddrGet">
<summary>
 Generate a ldflda on an &apos;a ref. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ILAsm">
<summary>
 IL assembly code - type list are the types pushed on the stack 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TupleFieldGet">
<summary>
 An operation representing a field-get from an F# tuple value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ExnFieldSet">
<summary>
 An operation representing a field-set on an F# exception value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ExnFieldGet">
<summary>
 An operation representing a field-get from an F# exception value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseFieldSet">
<summary>
 An operation representing a field-get from a union value. The value is not assumed to have been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseFieldGet">
<summary>
 An operation representing a field-get from a union value, where that value has been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseProof">
<summary>
 An operation representing a coercion that proves a union value is of a particular union case. This is not a test, its
 simply added proof to enable us to generate verifiable code for field access on union types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseTagGet">
<summary>
 An operation representing getting an integer tag for a union value representing the union case number
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ValFieldGetAddr">
<summary>
 An operation representing getting the address of a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ValFieldGet">
<summary>
 An operation representing getting a record or class field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ValFieldSet">
<summary>
 An operation representing setting a record or class field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Recd">
<summary>
 Construct a record or object-model value. The ValRef is for self-referential class constructors, otherwise 
 it indicates that we&apos;re in a constructor and the purpose of the expression is to 
 fill in the fields of a pre-created but uninitialized object, and to assign the initialized 
 version of the object into the optional mutable cell pointed to be the given value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TryFinally">
<summary>
 An operation representing a lambda-encoded try/finally
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TryCatch">
<summary>
 An operation representing a lambda-encoded try/catch
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.For">
<summary>
 An operation representing a lambda-encoded for loop
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.While">
<summary>
 An operation representing a lambda-encoded while loop. The special while loop marker is used to mark compilations of &apos;foreach&apos; expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UInt16s">
<summary>
 Constant uint16 arrays (used for parser tables)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Bytes">
<summary>
 Constant byte arrays (used for parser tables and other embedded data)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Array">
<summary>
 An operation representing the creation of an array value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Tuple">
<summary>
 An operation representing the creation of a tuple value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ExnConstr">
<summary>
 An operation representing the creation of an exception value using an F# exception declaration
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCase">
<summary>
 An operation representing the creation of a union value of the particular union case
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Link">
<summary>
 Typechecking residue: A Expr.Link occurs for every use of a recursively bound variable. While type-checking 
 the recursive bindings a dummy expression is stored in the mutable reference cell. 
 After type checking the bindings this is replaced by a use of the variable, perhaps at an 
 appropriate type instantiation. These are immediately eliminated on subsequent rewrites. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.TyChoose">
<summary>
 Typechecking residue: Indicates a free choice of typars that arises due to 
 minimization of polymorphism at let-rec bindings.  These are 
 resolved to a concrete instantiation on subsequent rewrites. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Op">
<summary>
 An intrinsic applied to some (strictly evaluated) arguments 
 A few of intrinsics (TOp_try, TOp.While, TOp.For) expect arguments kept in a normal form involving lambdas 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.StaticOptimization">
<summary>
 If we statically know some infomation then in many cases we can use a more optimized expression 
 This is primarily used by terms in the standard library, particularly those implementing overloaded 
 operators. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Match">
<summary>
 Matches are a more complicated form of &quot;let&quot; with multiple possible destinations 
 and possibly multiple ways to get to each destination.  
 The first mark is that of the expression being matched, which is used 
 as the mark for all the decision making and binding that happens during the match. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Let">
<summary>
 Bind a value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.LetRec">
<summary>
 Bind a recursive set of values. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.App">
<summary>
 Applications.
 Applications combine type and term applications, and are normalized so 
 that sequential applications are combined, so &quot;(f x y)&quot; becomes &quot;f [[x];[y]]&quot;. 
 The type attached to the function is the formal function type, used to ensure we don&apos;t build application 
 nodes that over-apply when instantiating at function types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.TyLambda">
<summary>
 Type lambdas.  These are used for the r.h.s. of polymorphic &apos;let&apos; bindings and 
 for expressions that implement first-class polymorphic values. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Lambda">
<summary>
 Lambda expressions. 
 Why multiple vspecs? A Expr.Lambda taking multiple arguments really accepts a tuple. 
 But it is in a convenient form to be compile accepting multiple 
 arguments, e.g. if compiled as a toplevel static method. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Sequential">
<summary>
 Sequence expressions, used for &quot;a;b&quot;, &quot;let a = e in b;a&quot; and &quot;a then b&quot; (the last an OO constructor). 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Val">
<summary>
 Reference a value. The flag is only relevant if the value is an object model member 
 and indicates base calls and special uses of object constructors. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Const">
<summary>
 A constant expression. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr">
<summary>
 The big type of expressions.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparReprInfo">
<summary>
 Records the extra metadata stored about typars for type parameters
 compiled as &quot;real&quot; IL type parameters, specifically for values with 
 ValReprInfo. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ArgReprInfo">
<summary>
 Records the &quot;extra information&quot; for an argument compiled as a real
 method argument, specificially the argument name and attributes.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValReprInfo.ValReprInfo">
<summary>
 ValReprInfo (numTypars, args, result)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method (rather
 than a closure or a local), including argument names, attributes etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTreeTarget">
<summary>
 A target of a decision tree. Can be thought of as a little function, though is compiled as a local block. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.ActivePatternCase">
<summary>
 Test.ActivePatternCase(activePatExpr, activePatResTys, activePatIdentity, idx, activePatInfo)

 Run the active pattern and bind a successful result to a 
 variable in the remaining tree. 
     activePatExpr     -- The active pattern function being called, perhaps applied to some active pattern parameters.
     activePatResTys   -- The result types (case types) of the active pattern.
     activePatIdentity -- The value and the types it is applied to. If there are any active pattern parameters then this is empty. 
     idx               -- The case number of of the active pattern which the test relates to.
     activePatternInfo -- The extracted info for the active pattern.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.IsInst">
<summary>
 IsInst(source, target)

 Test if the input to a decision tree is an instance of the given type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.IsNull">
<summary>
 Test if the input to a decision tree is null 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.Const">
<summary>
 Test if the input to a decision tree is the given constant value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.ArrayLength">
<summary>
 Test if the input to a decision tree is an array of the given length 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.UnionCase">
<summary>
 Test if the input to a decision tree matches the given union case
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree.TDBind">
<summary>
 TDBind(binding, body)

 Bind the given value throught the remaining cases of the dtree. 
 These arise from active patterns and some optimizations to prevent
 repeated computations in decision trees.
    binding -- the value and the expression it is bound to
    body -- the rest of the decision tree
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree.TDSuccess">
<summary>
 TDSuccess(results, targets)

 Indicates the decision tree has terminated with success, calling the given target with the given parameters.
    results -- the expressions to be bound to the variables at the target
    target -- the target number for the continuation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree.TDSwitch">
<summary>
 TDSwitch(input, cases, default, range)

 Indicates a decision point in a decision tree. 
    input -- the expression being tested
    cases -- the list of tests and their subsequent decision trees
    default -- the default decision tree, if any
    range -- (precise documentation  needed)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree">
<summary>
 Decision trees. Pattern matching has been compiled down to
 a decision tree by this point.  The right-hand-sides (actions) of
 the decision tree are labelled by integers that are unique for that
 particular tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Const">
<summary>
 Constants in expressions
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribNamedArg">
<summary>
 AttribExpr(source, evaluated)
 AttribNamedArg(name,type,isField,value)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribExpr">
<summary>
 We keep both source expression and evaluated expression around to help intellisense and signature printing
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Attrib">
<summary>
 Attrib(kind,unnamedArgs,propVal,appliedToAGetterOrSetter,targetsOpt,range)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribKind.FSAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported F# assembly 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribKind.ILAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported .NET assembly 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.PickledModuleInfo">
<summary>
 Represents the information saved in the assembly signature data resource for an F# assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CcuResolutionResult">
<summary>
 The result of attempting to resolve an assembly name to a full ccu.
 UnresolvedCcu will contain the name of the assembly that could not be resolved.
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuThunk.orphanfixup">
<summary>
 ccu.orphanfixup is true when a reference is missing in the transitive closure of static references that
 may potentially be required for the metadata of referenced DLLs. It is set to true if the &quot;loader&quot;
 used in the F# metadata-deserializer or the .NET metadata reader returns a failing value (e.g. None).
 Note: When used from Visual Studio, the loader will not automatically chase down transitively referenced DLLs - they
 must be in the explicit references in the project.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.UsesQuotations(System.Boolean)">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.UsesQuotations">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.TypeForwarders">
<summary>
 The table of type forwarders for this assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.Stamp">
<summary>
 A unique stamp for this DLL 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.SourceCodeDirectory">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.RootTypeAndExceptionDefinitions">
<summary>
 The table of type definitions at the &quot;root&quot; of the assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.RootModulesAndNamespaces">
<summary>
 The table of modules and namespaces at the &quot;root&quot; of the assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.QualifiedName">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.IsProviderGenerated">
<summary>
 Is the CCu an EST injected assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.IsFSharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler and has F# metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.ILScopeRef">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.FileName">
<summary>
 Holds the filename for the DLL, if any 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.Contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.TryForward(System.String[],System.String)">
<summary>
 Try to resolve a path into the CCU by referencing the .NET/CLI type forwarder table of the CCU
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.MemberSignatureEquality(Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Used to make forward calls into the type/assembly loader when comparing member signatures during linking
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.ImportProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType})">
<summary>
 Used to make &apos;forward&apos; calls into the loader during linking
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.FixupOrphaned">
<summary>
 Fixup a CCU to record it as &quot;orphaned&quot;, i.e. not available
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.Fixup(Microsoft.FSharp.Compiler.Tast.CcuThunk)">
<summary>
 Fixup a CCU to have the given contents
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.EnsureDerefable(System.String[])">
<summary>
 Ensure the ccu is derefable in advance. Supply a path to attach to any resulting error message.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.CreateDelayed(System.String)">
<summary>
 Create a CCU with the given name but where the contents have not yet been specified
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.Create(System.String,Microsoft.FSharp.Compiler.Tast.CcuData)">
<summary>
 Create a CCU with the given name and contents
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CcuThunk">
<summary>
 A relinkable handle to the contents of a compilation unit. Relinking is performed by mutation.
 A compilation unit is, more or less, the new material created in one
 invocation of the compiler.  Due to static linking assemblies may hold more 
 than one compilation unit (i.e. when two assemblies are merged into a compilation
 the resulting assembly will contain 3 CUs).  Compilation units are also created for referenced
 .NET assemblies. 
 
 References to items such as type constructors are via 
 cross-compilation-unit thunks, which directly reference the data structures that define
 these modules.  Thus, when saving out values to disk we only wish 
 to save out the &quot;current&quot; part of the term graph.  When reading values
 back in we &quot;fixup&quot; the links to previously referenced modules.

 All non-local accesses to the data structures are mediated
 by ccu-thunks.  Ultimately, a ccu-thunk is either a (named) element of
 the data structure, or it is a delayed fixup, i.e. an invalid dangling
 reference that has not had an appropriate fixup applied.  
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CcuTypeForwarderTable">
<summary>
 Represents a table of .NET CLI type forwarders for an assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.TypeForwarders">
<summary>
 The table of .NET CLI type forwarders for this assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.MemberSignatureEquality">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality 
 logic in tastops.fs
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.Contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.UsesQuotations">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.ImportProvidedType">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality 
 logic in tastops.fs
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.InvalidateEvent">
<summary>
 Triggered when the contents of the CCU are invalidated
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.IsProviderGenerated">
<summary>
 Is the CCu an assembly inected by a type provider
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.IsFSharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler and has F# metadata
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.SourceCodeDirectory">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.QualifiedName">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.Stamp">
<summary>
 A unique stamp for this DLL 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.ILScopeRef">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.FileName">
<summary>
 Holds the filename for the DLL, if any 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureOne">
<summary>
 The unit of measure &apos;1&apos;, e.g. float = float&lt;1&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureInv">
<summary>
 An inverse of a units of measure expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureProd">
<summary>
 A product of two units of measure
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureCon">
<summary>
 A constant, leaf unit-of-measure such as &apos;kg&apos; or &apos;m&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureVar">
<summary>
 A variable unit-of-measure
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_measure">
<summary>
 Indicates the type is a unit-of-measure expression being used as an argument to a type or member
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_var">
<summary>
 Indicates the type is a variable type, whether declared, generalized or an inference type parameter  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_ucase">
<summary>
 TType_ucase(unionCaseRef, typeInstantiation)

 Indicates the type is a non-F#-visible type representing a &quot;proof&quot; that a union value belongs to a particular union case
 These types are not user-visible and will never appear as an inferred type. They are the types given to
 the temporaries arising out of pattern matching on union values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_fun">
<summary>
 TType_fun(domainType,rangeType).

 Indicates the type is a function type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_tuple">
<summary>
 TType_tuple(elementTypes).

 Indicates the type is a tuple type. elementTypes must be of length 2 or greater.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_app">
<summary>
 TType_app(tyconRef, typeInstantiation).

 Indicates the type is build from a named type and a number of type arguments
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_forall">
<summary>
 TType_forall(typars, bodyTy).

 Indicates the type is a universal type, only used for types of values and members 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType">
<summary>
 The algebra of types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValRef.binding">
<summary>
 Indicates a reference to something bound in this CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRef">
<summary>
 References are either local or nonlocal
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceRef">
<summary>
 note: ModuleOrNamespaceRef and TyconRef are type equivalent 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityRef.binding">
<summary>
 Indicates a reference to something bound in this CCU 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.XmlDocSig">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.XmlDoc">
<summary>
 The XML documentation of the entity, if any. If the entity is backed by provided metadata
 then this _does_ include this documentation. If the entity is backed by Abstract IL metadata
 or comes from another F# assembly then it does not (because the documentation will get read from 
 an XML file).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.UnionTypeInfo">
<summary>
 Get the union cases and other union-type information for a type, if any
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.UnionCasesAsList">
<summary>
 Get the union cases for a type, if any, as a list
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.UnionCasesArray">
<summary>
 Get the union cases for a type, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeReprInfo">
<summary>
 The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeReprAccessibility">
<summary>
 Get the value representing the accessiblity of the r.h.s. of an F# type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeOrMeasureKind">
<summary>
 The kind of the type definition - is it a measure definition or a type definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeContents">
<summary>
 The logical contents of the entity when it is a type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TyparsNoRange">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TrueInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition,
 excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TrueFieldsAsList">
<summary>
 Get a list of all fields for F#-defined record, struct and class fields in this type definition,
 including static fields, but excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Stamp">
<summary>
 A unique stamp for this module, namespace or type definition within the context of this compilation. 
 Note that because of signatures, there are situations where in a single compilation the &quot;same&quot; 
 module, namespace or type may have two distinct Entity objects that have distinct stamps.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Range">
<summary>
 The code location where the module, namespace or type is defined.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.PublicPath">
<summary>
 Get a blob of data indicating how this type is nested in other namespaces, modules or types.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.PreEstablishedHasDefaultConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a default constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ModuleOrNamespaceType">
<summary>
 The logical contents of the entity when it is a module or namespace fragment.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.MembersOfFSharpTyconSorted">
<summary>
 Gets the immediate members of an F# type definition, excluding compiler-generated ones.
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.MembersOfFSharpTyconByName">
<summary>
 Gets all immediate members of an F# type definition keyed by name, including compiler-generated ones.
 Note: result is a indexed table, and for each name the results are in reverse declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.LogicalName">
<summary>
 The name of the namespace, module or type, possibly with mangling, e.g. List`1, List or FailureException 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsUnionTycon">
<summary>
 Indicate if this is a type whose r.h.s. is known to be a union type definition.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsStructOrEnumTycon">
<summary>
 Indicates if this is a struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsRecordTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvidedNamespace">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvidedGeneratedTycon">
<summary>
 Indicates if the entity is a generated provided type definition, i.e. not erased.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvidedErasedTycon">
<summary>
 Indicates if the entity is an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvided">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsNamespace">
<summary>
 Indicates if the entity is a namespace
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsModuleOrNamespace">
<summary>
 Indicates the &quot;tycon blob&quot; is actually a module 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsMeasureableReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll like &apos;float&lt;_&gt;&apos; which
 defines a measure type with a relation to an existing non-measure type as a representation.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsILTycon">
<summary>
 Indicate if this is a type definition backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsILStructOrEnumTycon">
<summary>
 Indicates if this is a .NET-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsILEnumTycon">
<summary>
 Indicates if this is a .NET-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsHiddenReprTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. definition is unknown (i.e. a traditional ML &apos;abstract&apos; type in a signature,
 which in F# is called a &apos;unknown representation&apos; type).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpStructOrEnumTycon">
<summary>
 Indicates if this is an F#-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpObjectModelTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be some kind of F# object model definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpInterfaceTycon">
<summary>
 Indicates if this is an F#-defined interface type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpEnumTycon">
<summary>
 Indicates if this is an F#-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpDelegateTycon">
<summary>
 Indicates if this is an F#-defined delegate type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsExceptionDecl">
<summary>
 Indicates if the entity represents an F# exception declaration.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsErased">
<summary>
 Indicates if the entity is erased, either a measure definition, or an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsEnumTycon">
<summary>
 Indicates if this is an enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsAsmReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses 
 an assembly-code representation for the type, e.g. the primitive array type constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ImmediateInterfacesOfFSharpTycon">
<summary>
 Gets the immediate interface definitions of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ImmediateInterfaceTypesOfFSharpTycon">
<summary>
 Gets the immediate interface types of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Id">
<summary>
 The identifier at the point of declaration of the type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ILTyconRawMetadata">
<summary>
 Get the Abstract IL metadata for this type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ILTyconInfo">
<summary>
 Get the Abstract IL scope, nesting and metadata for this 
 type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.HasSelfReferentialConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a self-referential constructor using &apos;as x&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedHashAndEqualsWithComparerValues">
<summary>
 Gets any implicit hash/equals (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedHashAndEqualsValues">
<summary>
 Gets any implicit hash/equals methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedCompareToWithComparerValues">
<summary>
 Gets any implicit CompareTo (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedCompareToValues">
<summary>
 Gets any implicit CompareTo methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.FSharpObjectModelTypeInfo">
<summary>
 Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ExceptionInfo">
<summary>
 The information about the r.h.s. of an F# exception definition, if any. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DisplayNameWithStaticParametersAndUnderscoreTypars">
<summary>
 The display name of the namespace, module or type with &lt;_,_,_&gt; added for generic types,  including static parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DisplayNameWithStaticParameters">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, including static parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DisplayName">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, not including static parameters
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DemangledModuleOrNamespaceName">
<summary>
 Demangle the module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledRepresentationForNamedType">
<summary>
 Gets the data indicating the compiled representation of a named type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledRepresentation">
<summary>
 Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledReprCache">
<summary>
 Get the cache of the compiled ILTypeRef representation of this module or type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledName">
<summary>
 The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompilationPath">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules and types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CanDeref">
<summary>
 Is the destination assembly available?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Attribs">
<summary>
 The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata
 then this does not include any attributes from those sources.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition.
 including hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllFieldsAsList">
<summary>
 Get a list of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllFieldsArray">
<summary>
 Get an array of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllFieldTable">
<summary>
 Get a table of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Accessibility">
<summary>
 Get the value representing the accessiblity of an F# type definition or module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.Typars(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
 
 Lazy because it may read metadata, must provide a context &quot;range&quot; in case error occurs reading metadata.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.GetUnionCaseByName(System.String)">
<summary>
 Get a union case of a type by name
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.GetFieldByName(System.String)">
<summary>
 Get a field by name.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.GetFieldByIndex(System.Int32)">
<summary>
 Get a field by index in definition order
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryModuleOrNamespaceType">
<summary>
 Try to get the details of the module or namespace fragment referred to by this non-local reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryDeref">
<summary>
 Try to link a non-local entity reference to an actual entity
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.Path">
<summary>
 Get the path into the CCU referenced by the nonlocal reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.ModuleOrNamespaceType">
<summary>
 Get the details of the module or namespace fragment for the entity referred to by this non-local reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.LastItemMangledName">
<summary>
 Get the mangled name of the last item in the path of the nonlocal reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.EnclosingMangledPath">
<summary>
 Get the all-but-last names of the path of the nonlocal reference.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.Deref">
<summary>
 Dereference the nonlocal reference, and raise an error if this fails.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.Ccu">
<summary>
 Get the CCU referenced by the nonlocal reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.AssemblyName">
<summary>
 Get the name of the assembly referenced by the nonlocal reference.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryDerefEntityPathViaProvidedType(Microsoft.FSharp.Compiler.Tast.CcuThunk,System.String[],System.Int32,Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Try to find the entity correspondng to the given path, using type-providers to link the data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryDerefEntityPath(Microsoft.FSharp.Compiler.Tast.CcuThunk,System.String[],System.Int32,Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Try to find the entity correspondng to the given path in the given CCU
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef">
<summary>
 Index into the namespace/module structure of a particular CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.NonLocalValOrMemberRef.ItemKey">
<summary>
 The name of the value, or the full signature of the member
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.NonLocalValOrMemberRef.EnclosingEntity">
<summary>
 A reference to the entity containing the value or member. THis will always be a non-local reference
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValMemberInfo.IsImplemented">
<summary>
 Gets updated with &apos;true&apos; if an abstract slot is implemented in the file being typechecked.  Internal only. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValMemberInfo.ImplementedSlotSigs">
<summary>
 Updated with the full implemented slotsig after interface implementation relation is checked 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValMemberInfo.ApparentParent">
<summary>
 The parent type. For an extension member this is the type being extended 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_xmldocsig">
<summary>
 XML documentation signature for the value
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_xmldoc">
<summary>
 XML documentation attached to a value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_attribs">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup  
 these value references after copying a colelction of values. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_member_info">
<summary>
 Is the value actually an instance method/property/event that augments 
 a type, and if so what name does it take in the IL?
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_access">
<summary>
 How visible is this? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_defn">
<summary>
 What is the original, unoptimized, closed-term definition, if any? 
 Used to implement [&lt;ReflectedDefinition&gt;]
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_flags">
<summary>
 See vflags section further below for encoding/decodings here 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.XmlDocSig(System.String)">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.XmlDocSig">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.XmlDoc">
<summary>
 Get the declared documentation for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method.

 This indicates the number of arguments in each position for a curried 
 functions, and relates to the F# spec for arity analysis.
 For module-defined values, the currying is based 
 on the number of lambdas, and in each position the elements are 
 based on attempting to deconstruct the type of the argument as a 
 tuple-type.  

 The field is mutable because arities for recursive 
 values are only inferred after the r.h.s. is analyzed, but the 
 value itself is created before the r.h.s. is analyzed. 

 TLR also sets this for inner bindings that it wants to 
 represent as &quot;top level&quot; bindings.     
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.TypeScheme">
<summary>
 Get the type of the value including any generic type parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Type">
<summary>
 The type of the value. 
 May be a TType_forall for a generic value. 
 May be a type variable or type containing type variables during type inference. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Typars">
<summary>
 Get the generic type parameters for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.TopValActualParent">
<summary>
 Get the actual parent entity for the value (a module or a type), i.e. the entity under which the
 value will appear in compiled code. For extension members this is the module where the extension member
 is declared.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.TauType">
<summary>
 Get the type of the value after removing any generic type parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Stamp">
<summary>
 A unique stamp within the context of this invocation of the compiler process 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ReflectedDefinition">
<summary>
 The quotation expression associated with a value given the [&lt;ReflectedDefinition&gt;] tag
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.RecursiveValInfo">
<summary>
 Get the information about the value used during type inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Range">
<summary>
 The place where the value was defined. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.PublicPath">
<summary>
 Get the public path to the value, if any? Should be set if and only if
 IsMemberOrModuleBinding is set.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.PropertyName">
<summary>
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the property implemented by the abstract slot
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.PermitsExplicitTypeInstantiation">
<summary>
 Indicates if this is allows the use of an explicit type instantiation (i.e. does it itself have explciti type arguments,
 or does it have a signature?)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.NumObjArgs">
<summary>
 Get the number of &apos;this&apos;/&apos;self&apos; object arguments for the member. Instance extension members return &apos;1&apos;.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MustInline">
<summary>
 Indicates whether the inline declaration for the value indicate that the value must be inlined?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MemberInfo">
<summary>
 Is this a member, if so some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MemberApparentParent">
<summary>
 Get the apparent parent entity for a member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MakesNoCriticalTailcalls">
<summary>
 Indicates if this is inferred to be a method or function that definitely makes no critical tailcalls?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LogicalName">
<summary>
 The name of the method. 
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an extension member then this will be the simple name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LiteralValue">
<summary>
 The value of a value or member marked with [&lt;LiteralAttribute&gt;] 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LinkagePartialKey">
<summary>
 The partial information used to index the methods of all those in a ModuleOrNamespace.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LinkageFullKey">
<summary>
 The full information used to identify a specific overloaded method amongst all those in a ModuleOrNamespace.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsOverrideOrExplicitImpl">
<summary>
 Indicates if this value was a member declared &apos;override&apos; or an implementation of an interface slot
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsMutable">
<summary>
 Indicates if this is declared &apos;mutable&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsModuleBinding">
<summary>
 Indicates if this is an F#-defined value in a module, or an extension member, but excluding compiler generated bindings from optimizations
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsMemberOrModuleBinding">
<summary>
 Is this a member definition or module definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsMember">
<summary>
 Indicates if this is a member, and if so, gives some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsLinked">
<summary>
 Indicates if a value is linked to backing data yet. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsIntrinsicMember">
<summary>
 Indicates if this is a member, excluding extension members
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsInstanceMember">
<summary>
 Indicates if this is an F#-defined instance member. 

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsIncrClassGeneratedMember">
<summary>
 Indicates if this is a member generated from the de-sugaring of &apos;let&apos; function bindings in the implicit class syntax?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsIncrClassConstructor">
<summary>
 Indicates if this is a constructor member generated from the de-sugaring of implicit constructor for a class type?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsExtensionMember">
<summary>
 Indicates if this is an F#-defined extension member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsDispatchSlot">
<summary>
 Indicates if this member is an F#-defined dispatch slot.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsConstructor">
<summary>
 Indicates if this is an F#-defined &apos;new&apos; constructor member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompilerGenerated">
<summary>
 Indicates whether this value was generated by the compiler.

 Note: this is true for the overrides generated by hash/compare augmentations
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompiledIntoModule">
<summary>
 Indicates if this is something compiled into a module, i.e. a user-defined value, an extension member or a compiler-generated value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompiledAsTopLevel">
<summary>
 Is this represented as a &quot;top level&quot; static binding (i.e. a static field, static member,
 instance member), rather than an &quot;inner&quot; binding that may result in a closure.

 This is implied by IsMemberOrModuleBinding, however not vice versa, for two reasons.
 Some optimizations mutate this value when they decide to change the representation of a 
 binding to be IsCompiledAsTopLevel. Second, even immediately after type checking we expect
 some non-module, non-member bindings to be marked IsCompiledAsTopLevel, e.g. &apos;y&apos; in 
 &apos;let x = let y = 1 in y + y&apos; (NOTE: check this, don&apos;t take it as gospel)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompiledAsStaticPropertyWithoutField">
<summary>
 Indicates if the backing field for a static value is suppressed.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsClassConstructor">
<summary>
 Indicates if this is a compiler-generated class constructor member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.InlineInfo">
<summary>
 Get the inline declaration on the value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.HasBeenReferenced">
<summary>
 Indicates if this is ever referenced?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.DisplayName">
<summary>
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an operator then this is &apos;(+)&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.DefinitionRange">
<summary>
 Range of the definition (implementation) of the value, used by Visual Studio 
 Updated by mutation when the implementation is matched against the signature. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.CoreDisplayName">
<summary>
 The name of the method. 
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.CompiledName">
<summary>
 The name of the method in compiled code (with some exceptions where ilxgen.fs decides not to use a method impl)
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this may be a mangled name
   - If this is an extension member then this will be a mangled name
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.BaseOrThisInfo">
<summary>
 Indicates if this is a &apos;base&apos; or &apos;this&apos; value?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Attribs">
<summary>
 Get the declared attributes for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ApparentParent">
<summary>
 Get the apparent parent entity for the value, i.e. the entity under with which the
 value is associated. For extension members this is the nominal type the member extends.
 For other values it is just the actual parent.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ActualParent">
<summary>
 The parent type or module, if any (None for expression bindings and parameters)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Accessibility">
<summary>
 How visible is this value, function or member?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Val.NewUnlinked">
<summary>
 Create a new value with empty, unlinked data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Val.New(Microsoft.FSharp.Compiler.Tast.ValData)">
<summary>
 Create a new value with the given backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Val.Link(Microsoft.FSharp.Compiler.Tast.ValData)">
<summary>
 Link a value based on empty, unlinked data to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey.TypeForLinkage">
<summary>
 The full type of the value for the purposes of linking. May be None for non-members, since they can&apos;t be overloaded.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey.PartialKey">
<summary>
 The partial information used to index the value in a ModuleOrNamespace.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey">
<summary>
 The full information used to identify a specific overloaded method
 amongst all those in a ModuleOrNamespace.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.TotalArgCount">
<summary>
 Indicates the total argument count of the member.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.LogicalName">
<summary>
 Indicates the logical name of the member. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.MemberIsOverride">
<summary>
 Indicates if the member is an override. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.MemberParentMangledName">
<summary>
 The name of the type with which the member is associated. None for non-member values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey">
<summary>
 The partial information used to index the methods of all those in a ModuleOrNamespace.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.BuiltInSln">
<summary>
 Indicates a trait is solved by a &apos;fake&apos; instance of an operator, like &apos;+&apos; on integers
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.ClosedExprSln">
<summary>
 ClosedExprSln(expr)

 Indicates a trait is solved by an erased provided expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.ILMethSln">
<summary>
 ILMethSln(typ, extOpt, ilMethodRef, minst)

 Indicates a trait is solved by a .NET method.
    typ         -- the type and its instantiation
    extOpt      -- information about an extension member, if any
    ilMethodRef -- the method that solves the trait constraint
    minst       -- the generic method instantiation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.FSRecdFieldSln">
<summary>
 FSRecdFieldSln(tinst, rfref, isSetProp)

 Indicates a trait is solved by an F# record field.
    tinst   -- the instantiation of the declaring type
    rfref   -- the reference to the record field
    isSetProp -- indicates if this is a set of a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.FSMethSln">
<summary>
 FSMethSln(typ, vref, minst)

 Indicates a trait is solved by an F# method.
    typ   -- the type and its instantiation
    vref  -- the method that solves the trait constraint
    minst -- the generic method instantiation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln">
<summary>
 Indicates the solution of a member constraint during inference.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.TTrait">
<summary>
 TTrait(tys,nm,memFlags,argtys,rty,colution)

 Indicates the signature of a member constraint. Contains a mutable solution cell
 to store the inferred solution of the constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.Solution(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.TraitConstraintSln})">
<summary>
 Get or set the solution of the member constraint during inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.Solution">
<summary>
 Get or set the solution of the member constraint during inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.ReturnType">
<summary>
 Get the return type recorded in the member constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.MemberName">
<summary>
 Get the member name associated with the member constraint.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo">
<summary>
 The specification of a member constraint that must be solved 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsUnmanaged">
<summary>
 Indicates a constraint that a type is .NET unmanaged type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsDelegate">
<summary>
 Indicates a constraint that a type is a delegate from the given tuple of args to the given return type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SupportsEquality">
<summary>
 Indicates a constraint that a type does not have the Equality(false) attribute, or is not a structural type with this attribute, with special rules for some known structural container types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SupportsComparison">
<summary>
 Indicates a constraint that a type implements IComparable, with special rules for some known structural container types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsEnum">
<summary>
 Indicates a constraint that a type is an enum with the given underlying 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.RequiresDefaultConstructor">
<summary>
 Indicates a constraint that a type has a parameterless constructor 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SimpleChoice">
<summary>
 Indicates a constraint that a type is a simple choice between one of the given ground types. Only arises from &apos;printf&apos; format strings. See format.fs 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsReferenceType">
<summary>
 Indicates a constraint that a type is a reference type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsNonNullableStruct">
<summary>
 Indicates a constraint that a type is a non-Nullable value type 
 These are part of .NET&apos;s model of generic constraints, and in order to 
 generate verifiable code we must attach them to F# generalzied type variables as well. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.MayResolveMember">
<summary>
 Indicates a constraint that a type has a member with the given signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SupportsNull">
<summary>
 Indicates a constraint that a type has a &apos;null&apos; value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.DefaultsTo">
<summary>
 Indicates a default value for an inference type variable should it be netiher generalized nor solved 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.CoercesTo">
<summary>
 Indicates a constraint that a type is a subtype of the given type 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.Typar.AsType">
<summary>
 A cached TAST type used when this type variable is used as type.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.StaticReq">
<summary>
 Indicates if the type variable has a static &quot;head type&quot; requirement, i.e. ^a variables used in FSharp.Core and member constraints.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Stamp">
<summary>
 The unique stamp of the typar definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Solution">
<summary>
 The inferred equivalence for the type inference variable, if any.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Rigidity">
<summary>
 Indicates if the type variable can be sovled or given new constraints. The status of a type variable
 generally always evolves towards being either rigid or solved. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Kind">
<summary>
 Indicates whether a type variable can be instantiated by types or units-of-measure.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsSolved">
<summary>
 Indicates if a type variable has been solved.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsLinked">
<summary>
 Indicates if a type variable has been linked. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsFromError">
<summary>
 Indicates if the type inference variable was generated after an error when type checking expressions or patterns
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsErased">
<summary>
 Indicates whether a type variable is erased in compiled .NET IL code, i.e. whether it is a unit-of-measure variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsCompilerGenerated">
<summary>
 Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.EqualityConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the equality constraint is dependent on whether this type variable satisfies the equality constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.DynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.DisplayName">
<summary>
 Indicates the display name of a type variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Constraints">
<summary>
 The inferred constraints for the type inference variable, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.ComparisonConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the comparison constraint is dependent on whether this type variable satisfies the comparison constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables and parameters from .NET 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetStaticReq(Microsoft.FSharp.Compiler.Ast.TyparStaticReq)">
<summary>
 Sets whether a type variable has a static requirement
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetRigidity(Microsoft.FSharp.Compiler.Tast.TyparRigidity)">
<summary>
 Sets the rigidity of a type variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetIdent(Microsoft.FSharp.Compiler.Ast.Ident)">
<summary>
 Sets the identifier assocaited with a type variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetEqualityDependsOn(System.Boolean)">
<summary>
 Sets whether the equality constraint of a type definition depends on this type variable 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetDynamicReq(Microsoft.FSharp.Compiler.Tast.TyparDynamicReq)">
<summary>
 Sets whether a type variable is required at runtime
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetCompilerGenerated(System.Boolean)">
<summary>
 Sets whether a type variable is compiler generated
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetComparisonDependsOn(System.Boolean)">
<summary>
 Sets whether the comparison constraint of a type definition depends on this type variable 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.NewUnlinked">
<summary>
 Creates a type variable that contains empty data, and is not yet linked. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.New(Microsoft.FSharp.Compiler.Tast.TyparData)">
<summary>
 Creates a type variable based on the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.Link(Microsoft.FSharp.Compiler.Tast.TyparData)">
<summary>
 Links a previously unlinked type variable to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.FixupConstraints(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TyparConstraint})">
<summary>
 Adjusts the constraints associated with a type variable
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Typar">
<summary>
 A declared generic type/measure parameter, or a type/measure inference variable.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_constraints">
<summary>
 The inferred constraints for the type inference variable 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_solution">
<summary>
 An inferred equivalence for a type inference variable. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_xmldoc">
<summary>
 The documentation for the type parameter. Empty for type inference variables.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_stamp">
<summary>
 The unique stamp of the typar blob. 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_il_name">
<summary>
 MUTABILITY: we set the names of generalized inference type parameters to make the look nice for IL code generation 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_id">
<summary>
 MUTABILITY: we set the names of generalized inference type parameters to make the look nice for IL code generation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparData">
<summary>
 Backing data for type parameters and type inference variables
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Accessibility.TAccess">
<summary>
 Indicates the construct can only be accessed from any code in the given type constructor, module or assembly. [] indicates global scope. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Construct">
<summary>
 A set of static methods for constructing types.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.entities@1353">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypesByAccessNames">
<summary>
 Get a table of types defined within this module, namespace or type. The 
 table is indexed by both name and, for generic types, also by mangled name.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypeDefinitions">
<summary>
 Get a list of types defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypeAndExceptionDefinitions">
<summary>
 Get a list of type and exception definitions defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ModulesAndNamespacesByDemangledName">
<summary>
 Get a table of nested module and namespace fragments indexed by demangled name (so &apos;ListModule&apos; becomes &apos;List&apos;)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ModuleOrNamespaceKind">
<summary>
 Namespace or module-compiled-as-type? 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ModuleAndNamespaceDefinitions">
<summary>
 Get a list of module and namespace definitions defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ExceptionDefinitionsByDemangledName">
<summary>
 Get a table of F# exception definitions indexed by demangled name, so &apos;FailureException&apos; is indexed by &apos;Failure&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ExceptionDefinitions">
<summary>
 Get a list of F# exception definitions defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsByLogicalName">
<summary>
 Get a table of values indexed by logical name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsAndMembersByPartialLinkageKey">
<summary>
 Get a table of values and members indexed by partial linkage key, which includes name, the mangled name of the parent type (if any), 
 and the method argument count (if any).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsAndMembersByLogicalNameUncached">
<summary>
 Compute a table of values and members indexed by logical name.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsAndMembers">
<summary>
 Values, including members in F# types in this module-or-namespace-fragment. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllEntitiesByLogicalMangledName">
<summary>
 Get a table of entities indexed by both logical name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllEntitiesByCompiledAndLogicalMangledNames">
<summary>
 Get a table of entities indexed by both logical and compiled names
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllEntities">
<summary>
 Type, mapping mangled name to Tycon, e.g. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ActivePatternElemRefLookupTable">
<summary>
 Get a table of the active patterns defined in this module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypesByDemangledNameAndArity(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get a table of types defined within this module, namespace or type. The 
 table is indexed by both name and generic arity. This means that for generic 
 types &quot;List`1&quot;, the entry (List,1) will be present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TryLinkVal(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey)">
<summary>
 Try to find the member with the given linkage key in the given module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddVal(Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Return a new module or namespace type with a value added.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddProvidedTypeEntity(Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Mutation used in hosting scenarios to hold the hosted types in this module or namespace
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddModuleOrNamespaceByMutation(Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddEntity(Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Return a new module or namespace type with an entity added.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnNone">
<summary>
 Indicates that an exception is abstract, i.e. is in a signature file, and we do not know the representation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnFresh">
<summary>
 Indicates that an exception carries the given record of values 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnAsmRepr">
<summary>
 Indicates that an exception is shorthand for the given .NET exception type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnAbbrevRepr">
<summary>
 Indicates that an exception is an abbreviation for the given exception 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_id">
<summary>
 Name/declaration-location of the field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_fattribs">
<summary>
 Attributes attached to generated field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_pattribs">
<summary>
 Attributes attached to generated property 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_access">
<summary>
  Indicates the declared visibility of the field, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_const">
<summary>
 The default initialization info, for static literals 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_secret">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_volatile">
<summary>
 Indicates a volatile field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_static">
<summary>
 Indicates a static field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_type">
<summary>
 The type of the field, w.r.t. the generic parameters of the enclosing type constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_xmldocsig">
<summary>
 XML Documentation signature for the field
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_xmldoc">
<summary>
 Documentation for the field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_mutable">
<summary>
 Is the field declared mutable in F#? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecdField">
<summary>
 This may represent a &quot;field&quot; in either a struct, class, record or union
 It is normally compiled to a property.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.Attribs">
<summary>
 Attributes, attached to the generated static method to make instances of the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.Accessibility">
<summary>
  Indicates the declared visibility of the union constructor, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.Id">
<summary>
 Name/range of the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.XmlDocSig">
<summary>
 XML documentation signature for the case
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.XmlDoc">
<summary>
 Documentation for the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.CompiledName">
<summary>
 Name of the case in generated IL code 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.ReturnType">
<summary>
 Return type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.FieldTable">
<summary>
 Data carried by the case. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionData.CompiledRepresentation">
<summary>
 The ILX data structure representing the discriminated union. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionData.CasesTable">
<summary>
 The cases contained in the discriminated union. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionCases.CasesByName">
<summary>
 The cases of the discriminated union, indexed by name. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionCases.CasesByIndex">
<summary>
 The cases of the discriminated union, in declaration order. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconRecdFields.FieldsByName">
<summary>
 The fields of the record, indexed by name. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconRecdFields.FieldsByIndex">
<summary>
 The fields of the record, in declaration order. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconObjModelData.fsobjmodel_rfields">
<summary>
 The fields of the class, struct or enum 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconObjModelData.fsobjmodel_vslots">
<summary>
 The declared abstract slots of the class, interface or struct 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconObjModelData.fsobjmodel_kind">
<summary>
 Indicates whether the type declaration is a class, interface, enum, delegate or struct 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconEnum">
<summary>
 Indicates the type is an enumeration 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconDelegate">
<summary>
 Indicates the type is a delegate with the given Invoke signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconStruct">
<summary>
 Indicates the type is a struct 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconInterface">
<summary>
 Indicates the type is an interface 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconClass">
<summary>
 Indicates the type is a class (also used for units-of-measure)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsSuppressRelocate">
<summary>
 Indicates the type is generated, but type-relocation is suppressed
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsDelegate">
<summary>
 A flag read from the provided type and used to compute basic properties of the type definition.
 Reading is delayed, since it looks at the .BaseType
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.UnderlyingTypeOfEnum">
<summary>
 A type read from the provided type and used to compute basic properties of the type definition.
 Reading is delayed, since it does an import on the underlying type
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsEnum">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsStructOrEnum">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsInterface">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsSealed">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsClass">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.LazyBaseType">
<summary>
 The base type of the type. We use it to compute the compiled representation of the type for erased types.
 Reading is delayed, since it does an import on the underlying type
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.ProvidedType">
<summary>
 The underlying System.Type (wrapped as a ProvidedType to make sure we don&apos;t call random things on
 System.Type, and wrapped as Tainted to make sure we track which provider this came from, for reporting
 error messages)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.ResolutionEnvironment">
<summary>
 The parameters given to the provider that provided to this type.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo">
<summary>
 The information kept about a provided type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TNoRepr">
<summary>
 The &apos;NoRepr&apos; value here has four meanings: 
     (1) it indicates &apos;not yet known&apos; during the first 2 phases of establishing type definitions
     (2) it indicates &apos;no representation&apos;, i.e. &apos;type X&apos; in signatures
     (3) it is the setting used for exception definitions (!)
     (4) it is the setting used for modules and namespaces.
 
 It would be better to separate the &quot;not yet known&quot; and other cases out.
 The information for exception definitions should be folded into here.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TProvidedNamespaceExtensionPoint">
<summary>
 Indicates the representation information for a provided namespace.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TProvidedTypeExtensionPoint">
<summary>
 TProvidedTypeExtensionPoint

 Indicates the representation information for a provided type. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TMeasureableRepr">
<summary>
 Indicates the type is parameterized on a measure (e.g. float&lt;_&gt;) but erases to some other type (e.g. float)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TAsmRepr">
<summary>
 Indicates the type is implemented as IL assembly code using the given closed Abstract IL type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TILObjModelRepr">
<summary>
 TILObjModelRepr(scope, nesting, definition)

 Indicates the type is a type from a .NET assembly without F# metadata.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TFiniteUnionRepr">
<summary>
 Indicates the type is a discriminated union 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TRecdRepr">
<summary>
 Indicates the type is a record 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TFsObjModelRepr">
<summary>
 Indicates the type is a class, struct, enum, delegate or interface 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation">
<summary>
 The information for the contents of a type. Also used for a provided namespace.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_abstract">
<summary>
 Set to true if the type is determined to be abstract 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_closed">
<summary>
 Set to true at the end of the scope where proper augmentations are allowed 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_super">
<summary>
 Super type, if any 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_interfaces">
<summary>
 Interface implementations - boolean indicates compiler-generated 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_adhoc">
<summary>
 Properties, methods etc. as lookup table
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_adhoc_list">
<summary>
 Properties, methods etc. in declaration order. The boolean flag for each indicates if the
 member is known to be an explicit interface implementation. This must be computed and
 saved prior to remapping assembly information.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_hasObjectGetHashCode">
<summary>
 True if the type defined an Object.GetHashCode method. In this 
 case we give a warning if we auto-generate a hash method since the semantics may not match up
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_hash_and_equals_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralEquatable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_equals">
<summary>
 This is the value implementing the auto-generated equality 
 semantics if any. It is not present if the type defines its own implementation 
 of Object.Equals or if the type doesn&apos;t override Object.Equals implicitly. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_compare_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralComparable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_compare">
<summary>
 This is the value implementing the auto-generated comparison 
 semantics if any. It is not present if the type defines its own implementation 
 of IComparable or if the type doesn&apos;t implement IComparable implicitly. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_il_repr_cache">
<summary>
 Used during codegen to hold the ILX representation indicating how to access the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_cpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_accessiblity">
<summary>
 Indicates how visible is the entitiy is.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_pubpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_xmldocsig">
<summary>
 The XML document signature for this entity
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_xmldoc">
<summary>
 The declared documentation for the type or module 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_modul_contents">
<summary>
 This field is used when the &apos;tycon&apos; is really a module definition. It holds statically nested type definitions and nested modules 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_exn_info">
<summary>
 Field used when the &apos;tycon&apos; is really an exception definition
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_tcaug">
<summary>
 The methods and properties of the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_abbrev">
<summary>
 If non-None, indicates the type is an abbreviation for another type. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_repr">
<summary>
 The declared representation of the type, i.e. record, union, class etc. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_attribs">
<summary>
 The declared attributes for the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_repr_accessibility">
<summary>
 The declared accessibility of the representation, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_range">
<summary>
 The declaration location for the type constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_compiled_name">
<summary>
 The name of the type, possibly with `n mangling 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_logical_name">
<summary>
 The name of the type, possibly with `n mangling 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_stamp">
<summary>
 The unique stamp of the &quot;tycon blob&quot;. Note the same tycon in signature and implementation get different stamps 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_typars">
<summary>
 The declared type parameters of the type  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.XmlDocSig(System.String)">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.XmlDocSig">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.XmlDoc">
<summary>
 The XML documentation of the entity, if any. If the entity is backed by provided metadata
 then this _does_ include this documentation. If the entity is backed by Abstract IL metadata
 or comes from another F# assembly then it does not (because the documentation will get read from 
 an XML file).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.UnionTypeInfo">
<summary>
 Get the union cases and other union-type information for a type, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.UnionCasesAsList">
<summary>
 Get the union cases for a type, if any, as a list
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.UnionCasesArray">
<summary>
 Get the union cases for a type, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeReprInfo">
<summary>
 The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeReprAccessibility">
<summary>
 Get the value representing the accessiblity of the r.h.s. of an F# type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeOrMeasureKind">
<summary>
 The kind of the type definition - is it a measure definition or a type definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeContents">
<summary>
 The logical contents of the entity when it is a type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeAbbrev">
<summary>
 Get the type abbreviated by this type definition, if it is an F# type abbreviation definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TyparsNoRange">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TrueInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition,
 excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TrueFieldsAsList">
<summary>
 Get a list of all fields for F#-defined record, struct and class fields in this type definition,
 including static fields, but excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Stamp">
<summary>
 A unique stamp for this module, namespace or type definition within the context of this compilation. 
 Note that because of signatures, there are situations where in a single compilation the &quot;same&quot; 
 module, namespace or type may have two distinct Entity objects that have distinct stamps.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Range">
<summary>
 The code location where the module, namespace or type is defined.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.PublicPath">
<summary>
 Get a blob of data indicating how this type is nested in other namespaces, modules or types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.PreEstablishedHasDefaultConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a default constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ModuleOrNamespaceType">
<summary>
 The logical contents of the entity when it is a module or namespace fragment.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.MembersOfFSharpTyconSorted">
<summary>
 Gets the immediate members of an F# type definition, excluding compiler-generated ones.
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.MembersOfFSharpTyconByName">
<summary>
 Gets all immediate members of an F# type definition keyed by name, including compiler-generated ones.
 Note: result is a indexed table, and for each name the results are in reverse declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.LogicalName">
<summary>
 The name of the namespace, module or type, possibly with mangling, e.g. List`1, List or FailureException 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsUnionTycon">
<summary>
 Indicate if this is a type whose r.h.s. is known to be a union type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsTypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsStructOrEnumTycon">
<summary>
 Indicates if this is a struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsRecordTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvidedNamespace">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvidedGeneratedTycon">
<summary>
 Indicates if the entity is a generated provided type definition, i.e. not erased.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvidedErasedTycon">
<summary>
 Indicates if the entity is an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvided">
<summary>
 Indicates if the entity is a provided type or namespace definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsNamespace">
<summary>
 Indicates if the entity is a namespace
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsModuleOrNamespace">
<summary>
 Indicates the &quot;tycon blob&quot; is actually a module 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsMeasureableReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll like &apos;float&lt;_&gt;&apos; which
 defines a measure type with a relation to an existing non-measure type as a representation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsLinked">
<summary>
 Indicates if the entity is linked to backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsILTycon">
<summary>
 Indicate if this is a type definition backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsILStructOrEnumTycon">
<summary>
 Indicates if this is a .NET-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsILEnumTycon">
<summary>
 Indicates if this is a .NET-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsHiddenReprTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. definition is unknown (i.e. a traditional ML &apos;abstract&apos; type in a signature,
 which in F# is called a &apos;unknown representation&apos; type).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpStructOrEnumTycon">
<summary>
 Indicates if this is an F#-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpObjectModelTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be some kind of F# object model definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpInterfaceTycon">
<summary>
 Indicates if this is an F#-defined interface type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpEnumTycon">
<summary>
 Indicates if this is an F#-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpDelegateTycon">
<summary>
 Indicates if this is an F#-defined delegate type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpClassTycon">
<summary>
 Indicates if this is an F#-defined class type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsExceptionDecl">
<summary>
 Indicates if the entity represents an F# exception declaration.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsErased">
<summary>
 Indicates if the entity is erased, either a measure definition, or an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsEnumTycon">
<summary>
 Indicates if this is an enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsAsmReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses 
 an assembly-code representation for the type, e.g. the primitive array type constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ImmediateInterfacesOfFSharpTycon">
<summary>
 Gets the immediate interface definitions of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ImmediateInterfaceTypesOfFSharpTycon">
<summary>
 Gets the immediate interface types of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Id">
<summary>
 The identifier at the point of declaration of the type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ILTyconRawMetadata">
<summary>
 Get the Abstract IL metadata for this type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ILTyconInfo">
<summary>
 Get the Abstract IL scope, nesting and metadata for this 
 type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.HasSelfReferentialConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a self-referential constructor using &apos;as x&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedHashAndEqualsWithComparerValues">
<summary>
 Gets any implicit hash/equals (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedHashAndEqualsValues">
<summary>
 Gets any implicit hash/equals methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedCompareToWithComparerValues">
<summary>
 Gets any implicit CompareTo (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedCompareToValues">
<summary>
 Gets any implicit CompareTo methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.FSharpObjectModelTypeInfo">
<summary>
 Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ExceptionInfo">
<summary>
 The information about the r.h.s. of an F# exception definition, if any. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DisplayNameWithStaticParametersAndUnderscoreTypars">
<summary>
 The display name of the namespace, module or type with &lt;_,_,_&gt; added for generic types, plus static parameters if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DisplayNameWithStaticParameters">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, including static parameters if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DisplayName">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, and no static parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DemangledModuleOrNamespaceName">
<summary>
 Demangle the module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledRepresentationForNamedType">
<summary>
 Gets the data indicating the compiled representation of a named type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledRepresentation">
<summary>
 Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledReprCache">
<summary>
 Get the cache of the compiled ILTypeRef representation of this module or type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledName">
<summary>
 The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompilationPathOpt">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules and types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompilationPath">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules and types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Attribs">
<summary>
 The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata
 then this does not include any attributes from those sources.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition.
 including hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllGeneratedValues">
<summary>
 Gets all implicit hash/equals/compare methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllFieldsAsList">
<summary>
 Get a list of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllFieldsArray">
<summary>
 Get an array of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllFieldTable">
<summary>
 Get a table of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Accessibility">
<summary>
 Get the value representing the accessiblity of an F# type definition or module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.Typars(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
 
 Lazy because it may read metadata, must provide a context &quot;range&quot; in case error occurs reading metadata.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.SetAttribs(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Set the custom attributes on an F# type definition.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.NewUnlinked">
<summary>
 Create a new entity with empty, unlinked data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.New(System.String,Microsoft.FSharp.Compiler.Tast.EntityData)">
<summary>
 Create a new entity with the given backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.Link(Microsoft.FSharp.Compiler.Tast.EntityData)">
<summary>
 Link an entity based on empty, unlinked data to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.GetUnionCaseByName(System.String)">
<summary>
 Get a union case of a type by name
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.GetFieldByName(System.String)">
<summary>
 Get a field by name.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.GetFieldByIndex(System.Int32)">
<summary>
 Get a field by index in definition order
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.DemangleEntityName(System.String,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind)">
<summary>
 String &apos;Module&apos; off an F# module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.PublicPath">
<summary>
 A public path records where a construct lives within the global namespace
 of a CCU.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompilationPath">
<summary>
 The information ILXGEN needs about the location of an item
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind.Namespace">
<summary>
 Indicates that a &apos;module&apos; is really a namespace 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind.ModuleOrType">
<summary>
 Indicates that a module is compiled to a class with the same name as the original module 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind.FSharpModuleWithSuffix">
<summary>
 Indicates that a module is compiled to a class with the &quot;Module&quot; suffix added. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityFlags.ReservedBitForPickleFormatTyconReprFlag">
<summary>
 This bit is reserved for us in the pickle format, see pickle.fs, it&apos;s bing listed here to stop it ever being used for anything else
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.EntityFlags">
<summary>
 Encode entity flags into a bit field. We leave lots of space to allow for future expansion.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.StaticReq">
<summary>
 Indicates if the type variable has a static &quot;head type&quot; requirement, i.e. ^a variables used in FSharp.Core and member constraints.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.Rigidity">
<summary>
 Indicates if the type variable can be sovled or given new constraints. The status of a type variable
 generally always evolves towards being either rigid or solved. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata. We pickle this as int64 to allow for future expansion
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.Kind">
<summary>
 Indicates whether a type variable can be instantiated by types or units-of-measure.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.IsFromError">
<summary>
 Indicates if the type inference variable was generated after an error when type checking expressions or patterns
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.IsCompilerGenerated">
<summary>
 Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.EqualityConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the equality constraint is dependent on whether this type variable satisfies the equality constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.DynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.ComparisonConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the comparison constraint is dependent on whether this type variable satisfies the comparison constraint.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparFlags">
<summary>
 Encode typar flags into a bit field  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.Anon">
<summary>
 Indicates the type parameter derives from an &apos;_&apos; anonymous type
 For units-of-measure, we give a warning if this gets solved to &apos;1&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.Flexible">
<summary>
 Indicates the type parameter is an inference variable may be solved
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.WarnIfNotRigid">
<summary>
 Indicates we give a warning if the type parameter is ever solved
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.WillBeRigid">
<summary>
 Indicates the type parameter can&apos;t be solved, but the variable is not set to &quot;rigid&quot; until after inference is complete
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.Rigid">
<summary>
 Indicates the type parameter can&apos;t be solved
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity">
<summary>
 Indicates if the type variable can be sovled or given new constraints. The status of a type variable
 evolves towards being either rigid or solved. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ValFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.MemberThisVal">
<summary>
 Indicates the &apos;this&apos; value specified in a memberm e.g. &apos;x&apos; in &apos;member x.M() = 1&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.NormalVal">
<summary>
 Indicates a normal value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.BaseVal">
<summary>
 Indicates the value called &apos;base&apos; available for calling base class members
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.CtorThisVal">
<summary>
 Indicates a ref-cell holding &apos;this&apos; or the implicit &apos;this&apos; used throughout an 
 implicit constructor to access and set values
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparDynamicReq.Yes">
<summary>
 Indicates the type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparDynamicReq.No">
<summary>
 Indicates the type parameter is not needed at runtime and may be eliminated
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparDynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRecursiveScopeInfo.ValNotInRecScope">
<summary>
 The normal value for this flag when the value is not within its recursive scope 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRecursiveScopeInfo.ValInRecScope">
<summary>
 Set while the value is within its recursive scope. The flag indicates if the value has been eagerly generalized and accepts generic-recursive calls 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRecursiveScopeInfo">
<summary>
 A flag associated with values that indicates whether the recursive scope of the value is currently being processed, and 
 if the value has been generalized or not as yet.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.Never">
<summary>
 Indicates the value must never be inlined by the optimizer
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.Optional">
<summary>
 Indicates the value may optionally be inlined by the optimizer
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.Always">
<summary>
 Indicates the value is inlined but the .NET IL code for the function still exists, e.g. to satisfy interfaces on objects, but that it is also always inlined 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.PseudoVal">
<summary>
 Indicates the value must always be inlined and no .NET IL code is generated for the value/function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Unique">
<summary>
 Unique name generator for stamps attached to lambdas and object expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.combineModuleOrNamespaceTypes(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType)">
<summary>
 Combine module types when multiple namespace fragments contribute to the
 same namespace, making new module specs as we go.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.combineMaps``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
<summary>
 Combine two maps where the given function reconciles entries that have the same key
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NewModifiedVal(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValData,Microsoft.FSharp.Compiler.Tast.ValData},Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Create a Val based on an existing one using the function &apos;f&apos;. 
 We require that we be given the parent for the new Val. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NewModifiedModuleOrNamespace(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType},Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Create a module Tycon based on an existing one using the function &apos;f&apos;. 
 We require that we be given the parent for the new module. 
 We pass the new module to &apos;f&apos; in case it needs to reparent the 
 contents of the module. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NewModifiedTycon(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.EntityData,Microsoft.FSharp.Compiler.Tast.EntityData},Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Create a tycon based on an existing one using the function &apos;f&apos;. 
 We require that we be given the new parent for the new tycon. 
 We pass the new tycon to &apos;f&apos; in case it needs to reparent the 
 contents of the tycon. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.accessSubstPaths(Microsoft.FSharp.Compiler.Tast.CompilationPath,Microsoft.FSharp.Compiler.Tast.CompilationPath,Microsoft.FSharp.Compiler.Tast.Accessibility)">
<summary>
 Given (newPath,oldPath) replace oldPath by newPath in the TAccess.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.primValRefEq(System.Boolean,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Primitive routine to compare two ValRef&apos;s for equality.  On the whol value identity is not particularly
 significant in F#. However it is significant for
    (a) Active Patterns 
    (b) detecting uses of &quot;special known values&quot; from FSharp.Core.dll, such as &apos;seq&apos; 
        and quotation splicing 

 Note this routine doesn&apos;t take type forwarding into account
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.primUnionCaseRefEq(System.Boolean,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.UnionCaseRef,Microsoft.FSharp.Compiler.Tast.UnionCaseRef)">
<summary>
 Primitive routine to compare two UnionCaseRef&apos;s for equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.primEntityRefEq(System.Boolean,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Primitive routine to compare two EntityRef&apos;s for equality
 This takes into account the possibility that they may have type forwarders
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.nonLocalRefDefinitelyNotEq(Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef,Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef)">
<summary>
 This predicate tests if non-local resolution paths are definitely known to resolve
 to different entities. All references with different named paths always resolve to 
 different entities. Two references with the same named paths may resolve to the same 
 entities even if they reference through different CCUs, because one reference
 may be forwarded to another via a .NET TypeForwarder.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.rescopePubPath(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.PublicPath)">
<summary>
 From Ref_private to Ref_nonlocal when exporting data.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.rescopePubPathToParent(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.PublicPath)">
<summary>
 From Ref_private to Ref_nonlocal when exporting data.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.mkModuleUnionCaseRef(Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.Entity,Microsoft.FSharp.Compiler.Tast.UnionCase)">
<summary>
 Make a reference to a union case for type in a module or namespace
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.|ValDeref|(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 For derefencing in the middle of a pattern
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ccuEq(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.CcuThunk)">
<summary>
 Equality on CCU references, implemented as reference equality except when unresolved
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.valEq(Microsoft.FSharp.Compiler.Tast.Val,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Equality on value specs, implemented as reference equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.typarRefEq(Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Equality on type varialbes, implemented as reference equality. This should be equivalent to using typarEq.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.KeyTyconByAccessNames``1(System.String,``0)">
<summary>
 Generic types can be accessed either by &apos;List&apos; or &apos;List`1&apos;. This lists both keys. The second form should really be deprecated.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.mustinline(Microsoft.FSharp.Compiler.Tast.ValInline)">
<summary>
 Returns true if the implementation of a value must always be inlined
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.globalStableNameGenerator">
<summary>
 A global generator of stable compiler generated names
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.globalNng">
<summary>
 A global generator of compiler generated names
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.newStamp">
<summary>
 Unique name generator for stamps attached to to val_specs, tycon_specs etc.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.verboseStamps">
<summary>
verboseStamps: print #stamp on each id -- very verbose - but sometimes useful. Turn on using &apos;--stamps&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValReprInfoModule">
<summary>
 Metadata on values (names of arguments etc. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TyconRefMultiMap`1">
<summary>
 Maps TyconRef to list of T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TyconRefMap`1">
<summary>
 Maps TyconRef to T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TyparMap`1">
<summary>
 Maps Typar to T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.ValMultiMap`1">
<summary>
 Maps Val&apos;s to list of T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.ValHash`1">
<summary>
 Mutable data structure mapping Val&apos;s to T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.ValMap`1">
<summary>
 Maps Val to T, based on stamps
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TypeScheme">
<summary>
 TypeSchme (generalizedTypars, tauTy)

    generalizedTypars -- the truly generalized type parameters 
    tauTy  --  the body of the generalized type. A &apos;tau&apos; type is one with its type paramaeters stripped off.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.|SpecialComparableHeadType|_|(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Determines types that are potentially known to satisfy the &apos;comparable&apos; constraint and returns
 a set of residual types that must also satisfy the constraint
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.TryDecodeTypeProviderAssemblyAttr(Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribute)">
<summary>
 returns Some(assemblyName) for success
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.StripSelfRefCell(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 For &quot;type Class as self&quot;, &apos;self&apos; is fixed up after initialization. To support this,
 it is converted behind the scenes to a ref. This function strips off the ref and
 returns the underlying type.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.rankOfArrayTy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the rank of an array type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.destArrayTy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the element type of an array type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkValAddr(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 &amp;localv           
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkAddrGet(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 *localv_ptr        
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkAddrSet(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
  *localv_ptr = e   
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkValSet(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
   localv &lt;- e      
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.IsHiddenTycon(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tastops.Remap,Microsoft.FSharp.Compiler.Tastops.SignatureHidingInfo}},Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Query SignatureRepackageInfo
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.freeInBindingRhs(Microsoft.FSharp.Compiler.Tastops.FreeVarOptions,Microsoft.FSharp.Compiler.Tast.Binding)">
<summary>
 Get the free variables in the right hand side of a binding.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.freeInExpr(Microsoft.FSharp.Compiler.Tastops.FreeVarOptions,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Get the free variables in an expression.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.freeInModuleOrNamespace(Microsoft.FSharp.Compiler.Tastops.FreeVarOptions,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr)">
<summary>
 Get the free variables in a module definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.qualifiedMangledNameOfTyconRef(Microsoft.FSharp.Compiler.Tast.EntityRef,System.String)">
<summary>
 A unique qualified name for each type definition, used to qualify the names of interface implementation methods
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.fullDisplayTextOfModRef(Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Return the full text for an item as we want it displayed to the user as a fully qualified entity
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.tryNiceEntityRefOfTy(Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try to get a TyconRef for a type without erasing type abbreviations
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.stripExnEqns(Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 See through F# exception abbreviations
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.stripTyEqnsA(Microsoft.FSharp.Compiler.Env.TcGlobals,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 set bool to &apos;true&apos; to allow shortcutting of type parameter equation chains during stripping 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkLocal(Microsoft.FSharp.Compiler.Range.range,System.String,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Return the local and an expression to reference it
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.exprForVal(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Note: try to use exprForValRef or the expression returned from mkLocal instead of this. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.DebugPrint">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.SimplifyTypes">
<summary>
 Utilities used in simplifying types for visual presentation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.PrettyTypes">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops">
<summary>
 Derived expression manipulation and construction functions.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tlr">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.TypeChecker">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.CalledArg">
<summary>
 CalledArg(pos,isParamArray,optArgInfo,isOutArg,nmOpt,argType)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.CallerArg`1">
<summary>
 In the following, &apos;T gets instantiated to: 
   1. the expression being supplied for an argument 
   2. &quot;unit&quot;, when simply checking for the existence of an overload that satisfies 
      a signature, or when finding the corresponding witness. 
 Note the parametricity helps ensure that overload resolution doesn&apos;t depend on the 
 expression on the callside (though it is in some circumstances allowed 
 to depend on some type information inferred syntactically from that 
 expression, e.g. a lambda expression may be converted to a delegate as 
 an adhoc conversion. 

 The bool indicates if named using a &apos;?&apos; 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.OverrideInfo">
<summary>
 The overall information about a method implementation in a class or object expression 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.BuildNewDelegateExpr(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Infos.EventInfo},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Implements the elaborated form of adhoc conversions from functions to delegates at member callsites
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.BuildMethodCall(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType}}}}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tastops.Mutates,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build an expression that calls a given method info. 
 This is called after overload resolution, and also to call other 
 methods such as &apos;setters&apos; for properties. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.TakeObjAddrForMethodCall``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Tastops.Mutates,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,``0}}})">
<summary>
 Adjust the &apos;this&apos; pointer before making a call 
 Take the address of a struct, and coerce to an interface/base/constraint type if necessary 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.ComputeConstrainedCallInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Compute whether we insert a &apos;coerce&apos; on the &apos;this&apos; pointer for an object model call 
 For example, when calling an interface method on a struct, or a method on a constrained 
 variable type. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.IsBaseCall(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Is this a &apos;base&apos; call (in the sense of C#) 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.GetAbstractPropInfosForSynPropertyDecl``2(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Ast.Ident,Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Typrelns.SlotImplSet}},``0,``1)">
<summary>
 Get the proeprties relevant to deterimining if a uniquely-identified-override exists based on the syntactic information 
 at the member signature prior to type inference. This is used to pre-assign type information if it does 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.GetAbstractMethInfosForSynMethodDecl(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Ast.Ident,Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Typrelns.SlotImplSet}},Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Get the methods relevant to deterimining if a uniquely-identified-override exists based on the syntactic information 
 at the member signature prior to type inference. This is used to pre-assign type information if it does 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.FindUniqueFeasibleSupertype(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 &quot;Single Feasible Type&quot; inference
 Look for the unique supertype of ty2 for which ty2 :&gt; ty1 might feasibly hold
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.FinalTypeDefinitionChecksAtEndOfInferenceScope(Microsoft.FSharp.Compiler.Infos.InfoReader,System.Boolean,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 &quot;Type Completion&quot; inference and a few other checks at the end of the
 inference scope
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.IteratedAdjustArityOfLambda(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.ValReprInfo,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Do AdjustArityOfLambdaBody for a series of  
 iterated lambdas, producing one method.  
 The required iterated function arity (List.length topValInfo) must be identical 
 to the iterated function arity of the input lambda (List.length vsl) 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.tryDestTopLambda(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.ValReprInfo,Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Break apart lambdas. Needs ChooseTyparSolutionsForFreeChoiceTypars because it&apos;s used in
 PostTypecheckSemanticChecks before we&apos;ve eliminated these nodes.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.ChooseTyparSolutionAndRange(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Choose solutions for Expr.TyChoose type &quot;hidden&quot; variables introduced
 by letrec nodes. Also used by the pattern match compiler to choose type
 variables when compiling patterns at generalized bindings.
     e.g. let ([],x) = ([],[])
 Here x gets a generalized type &quot;list&lt;&apos;T&gt;&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.TypeFeasiblySubsumesType(System.Int32,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Typrelns.CanCoerce,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 The feasible coercion relation. Part of the language spec.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.TypesFeasiblyEquiv``1(System.Int32,Microsoft.FSharp.Compiler.Env.TcGlobals,``0,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 The feasible equivalence relation. Part of the language spec.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.ProvidedMethodCalls.eraseSystemType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType})">
<summary>
 Erasure over System.Type.

 This is a reimplementation of the logic of provided-type erasure, working entirely over (tainted, provided) System.Type
 values. This is used when preparing ParameterInfo objects to give to the provider in GetInvokerExpression. 
 These ParameterInfo have erased ParameterType - giving the provider an erased type makes it considerably easier 
 to implement a correct GetInvokerExpression.

 Ideally we would implement this operation by converting to an F# TType using ImportSystemType, and then erasing, and then converting
 back to System.Type. However, there is currently no way to get from an arbitrary F# TType (even the TType for 
 System.Object) to a System.Type to give to the type provider.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.ProvidedMethodCalls">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.GetSlotImplSets(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Boolean,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Range.range}})">
<summary>
 Get the slots of a type that can or must be implemented. This depends
 partly on the full set of interface types that are being implemented
 simultaneously, e.g.
    { new C with  interface I2 = ... interface I3 = ... }
 allReqdTys = {C;I2;I3}

 allReqdTys can include one class/record/union type. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.CheckOverridesAreAllUsedOnce(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.RequiredSlot}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo})">
<summary>
 6b. check all implementations implement some virtual method 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.CheckDispatchSlotsAreImplemented(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.RequiredSlot},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo})">
<summary>
 6a. check all interface and abstract methods are implemented 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.SignatureConformance.CheckNamesOfModuleOrNamespaceContents(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType)">
<summary>
 Check the names add up between a signature and its implementation. We check this first.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.SignatureConformance">
<summary>
 Containment relation for module types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns">
<summary>
 Primary relations on types and signatures, with the exception of
 constraint solving and method overload resolution.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.UnicodeLexing">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Viz.Visualizable.Make(System.Object)">
<summary>
 assuming this assembly is already in the debuggee process, then Viz.Visualiable.Make(foo) in the Watch window will make a visualizer for foo
</summary>
</member>
<member name="">

</member>
<member name="T:Viz.Visualizable">
<summary>
 This type exists to have a concrete &apos;Target&apos; type for a DebuggerVisualizerAttribute.
 Ideally it would be out in its own assembly, but then the compiler would need to take a dependency on that assembly, so instead we 
 pragmatically just shove this into the compiler assembly itself.
</summary>
</member>
</members>
</doc>
